---
title: "操作系统"
date: 2022-04-12T16:25:02+08:00
draft: false
categories: [操作系统]
series: [面试]
tags: [操作系统, 面试]
summary: "操作系统面试相关内容."
---

# 操作系统理论知识



## 内存管理

内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

### 虚拟内存

操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来

- 程序中使用到的内存地址为虚拟内存地址
- 实际中硬件中的空间地址为物理内存地址

> 为什么要有虚拟内存？

- 虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。
- 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间



> 局部性原理

1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。



> 虚拟内存（虚拟存储器）的技术实现？

1. **请求分页存储管理** ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
2. **请求分段存储管理** ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. **请求段页式存储管理**



> 请求分页与分页存储管理，两者有何不同呢？

请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因

它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。



### 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。

![内存分段-寻址的方式](/images/操作系统.assets/6-分段寻址.jpg)



内存分段的不足之处：

- 内存碎片
  - 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决
  - 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费
- 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢



### 内存分页

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫**页**（*Page*）。在 Linux 下，每一页的大小为 `4KB`。

![内存分页寻址](/images/操作系统.assets/11-分页寻址.jpg)



不足：

- 页表会非常大，使用多级页表解决



#### 多级页表

![二级分页](/images/操作系统.assets/13-二级页表.jpg)

如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表



### 段页式内存管理

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

![段页式管理中的段表、页表与内存的关系](/images/操作系统.assets/18-段页式寻址.jpg)

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。



### 页面置换算法

- 最佳页面置换算法
- 先进先出置换算法
- 最近最久未使用的页面置换算法
- 时钟页面置换算法
- 最不常用页面置换算法



### 磁盘调度算法

- 先来先服务算法
- 最短寻道时间优先算法
- 扫描算法
- 循环扫描算法
- LOOK与C-LOOK算法



## 进程管理

### 线程

运行中的程序叫线程



> 进程的状态？

- 创建态：正在被创建的状态
- 就绪态：可运行，但是其他进程在运行
- 运行态：占用CPU在运行
- 阻塞态：不满足可运行的条件，在等待某一事件发生
- 终止态：正在从系统中消失的状态

在七状态模型中还有两种状态：

- 阻塞挂起状态：进程在外存且等待某一事件发生
- 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行



> 进程创建的过程？

1. 为新进程分配分配唯一的进程标识符，申请一个PCB
2. 为进程分配资源
3. 初始化PCB
4. 如果进程的调度队列能够接纳，就插入到就绪队列



#### 进程控制块PCB

PCB是进程的唯一标识，包含以下信息：

- 进程描述信息：进程标识符、用户标识符
- 进程控制和管理信息：进程状态、进程优先级
- 资源分配清单
- CPU相关信息



> PCB是如何组织的？

PCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列



#### 进程间通信方式

- 管道：输出数据是单向的，Linux中的`|`
- 命名管道FIFO：可在不相关的进程间进行相互通信
  - 管道的通信方式效率低，不适合进程间频繁的交换数据
- 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销
- 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中
- 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据
  - P操作减一，V操作加一
- 信号：进程间通信机制唯一的异步通信机制
- Socket





### 线程

线程是进程当中的一条执行流程



> 线程的优缺点？

优点：

- 一个进程可以同时存在多个进程
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

缺点：

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）



### 进程线程对比

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；



### 调度算法

- 先来先服务算法
- 最短作业优先调度算法
- 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间）
- 时间片轮转调度算法
- 最高优先级调度算法
- 多级反馈队列调度算法

