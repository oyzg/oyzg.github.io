<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>二叉树 | My Favorite</title><meta name=keywords content="数据结构,算法,面试,二叉树,BFS,DFS"><meta name=description content="二叉树相关."><meta name=author content><link rel=canonical href=https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/><link href=/assets/css/stylesheet.min.d597aab94c71b49b163b6ac67c7958079589ea1a0b7300e8a0014e1d2023b95e.css integrity="sha256-1ZequUxxtJsWO2rGfHlYB5WJ6hoLcwDooAFOHSAjuV4=" rel="preload stylesheet" as=style><link rel=icon href=https://oyzg.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oyzg.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oyzg.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://oyzg.github.io/apple-touch-icon.png><link rel=mask-icon href=https://oyzg.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.96.0"><meta property="og:title" content="二叉树"><meta property="og:description" content="二叉树相关."><meta property="og:type" content="article"><meta property="og:url" content="https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="article:published_time" content="2022-05-21T21:53:39+08:00"><meta property="article:modified_time" content="2022-05-21T21:53:39+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="二叉树"><meta name=twitter:description content="二叉树相关."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Archives","item":"https://oyzg.github.io/archives/"},{"@type":"ListItem","position":2,"name":"二叉树","item":"https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"二叉树","name":"二叉树","description":"二叉树相关.","keywords":["数据结构","算法","面试","二叉树","BFS","DFS"],"articleBody":"二叉树 基础 先来看看定义：\n// Java public class TreeNode {  int val; // 值  TreeNode left; // 左节点  TreeNode right;// 右节点  TreeNode() {}  TreeNode(int val) { this.val = val; } } // Go type TreeNode struct {  Val int  Left *TreeNode  Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n 深度优先遍历（DFS）  前序遍历 中序遍历 后序遍历   广度优先遍历（BFS）  深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n 确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int {  res := []int{}  var preorder func(root *TreeNode)  preorder = func(root * TreeNode) {  if root == nil {  return  }  res = append(res, root.Val)  preorder(root.Left)  preorder(root.Right)  }  preorder(root)  return res }  // 中序遍历 func inorderTraversal(root *TreeNode) []int {  res := []int{}  var inorder func(root *TreeNode)  inorder = func(root * TreeNode) {  if root == nil {  return  }  inorder(root.Left)  res = append(res, root.Val)  inorder(root.Right)  }  inorder(root)  return res }  // 后序遍历 func postorderTraversal(root *TreeNode) []int {  res := []int{}  var postorder func(root *TreeNode)  postorder = func(root * TreeNode) {  if root == nil {  return  }  postorder(root.Left)  postorder(root.Right)  res = append(res, root.Val)  }  postorder(root)  return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  stack := []*TreeNode{root}  for len(stack)  0 {  node := stack[len(stack)-1]  stack = stack[:len(stack)-1]  res = append(res, node.Val)  if node.Right != nil {  stack = append(stack, node.Right)  }  if node.Left != nil {  stack = append(stack, node.Left)  }  }  return res }  // 中序遍历 func inorderTraversal(root *TreeNode) []int {  res := []int{}  cur := root  stack := []*TreeNode{}  for cur != nil || len(stack)  0 {  if cur != nil {  stack = append(stack, cur)  cur = cur.Left  } else {  cur = stack[len(stack)-1]  stack = stack[:len(stack)-1]  res = append(res, cur.Val)  cur = cur.Right  }  }  return res }  // 后序遍历 func postorderTraversal(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  stack := []*TreeNode{root}  for len(stack)  0 {  node := stack[len(stack)-1]  stack = stack[:len(stack)-1]  res = append(res, node.Val)  if node.Left != nil {  stack = append(stack, node.Left)  }  if node.Right != nil {  stack = append(stack, node.Right)  }  }  reverse(res)  return res } func reverse(a []int) {  l, r := 0, len(a) - 1  for l r {  a[l], a[r] = a[r], a[l]  l, r = l+1, r-1  } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { \tif root == nil { \treturn nil \t} \tvar stack = list.New()//栈  res:=[]int{}//结果集  stack.PushBack(root)  var node *TreeNode  for stack.Len()0{  e := stack.Back()  stack.Remove(e)//弹出元素  if e.Value==nil{// 如果为空，则表明是需要处理中间节点  e=stack.Back()//弹出元素（即中间节点）  stack.Remove(e)//删除中间节点  node=e.Value.(*TreeNode)  res=append(res,node.Val)//将中间节点加入到结果集中  continue//继续弹出栈中下一个节点  }  node = e.Value.(*TreeNode)  //压栈顺序：右左中  if node.Right!=nil{  stack.PushBack(node.Right)  }  if node.Left!=nil{  stack.PushBack(node.Left)  }  stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符  stack.PushBack(nil)  }  return res  }  //中序遍历：左中右  //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int {  if root==nil{  return nil  }  stack:=list.New()//栈  res:=[]int{}//结果集  stack.PushBack(root)  var node *TreeNode  for stack.Len()0{  e := stack.Back()  stack.Remove(e)  if e.Value==nil{// 如果为空，则表明是需要处理中间节点  e=stack.Back()//弹出元素（即中间节点）  stack.Remove(e)//删除中间节点  node=e.Value.(*TreeNode)  res=append(res,node.Val)//将中间节点加入到结果集中  continue//继续弹出栈中下一个节点  }  node = e.Value.(*TreeNode)  //压栈顺序：右中左  if node.Right!=nil{  stack.PushBack(node.Right)  }  stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符  stack.PushBack(nil)  if node.Left!=nil{  stack.PushBack(node.Left)  }  }  return res }  //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { \tif root == nil { \treturn nil \t} \tvar stack = list.New()//栈  res:=[]int{}//结果集  stack.PushBack(root)  var node *TreeNode  for stack.Len()0{  e := stack.Back()  stack.Remove(e)  if e.Value==nil{// 如果为空，则表明是需要处理中间节点  e=stack.Back()//弹出元素（即中间节点）  stack.Remove(e)//删除中间节点  node=e.Value.(*TreeNode)  res=append(res,node.Val)//将中间节点加入到结果集中  continue//继续弹出栈中下一个节点  }  node = e.Value.(*TreeNode)  //压栈顺序：中右左  stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符  stack.PushBack(nil)  if node.Right!=nil{  stack.PushBack(node.Right)  }  if node.Left!=nil{  stack.PushBack(node.Left)  }  }  return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int {  res := [][]int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  level := []int{}  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, level)  }  return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int {  res := [][]int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  level := []int{}  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, level)  }  reverse(res)  return res }  func reverse(nums [][]int) {  i, j := 0, len(nums)-1  for i j {  nums[i], nums[j] = nums[j], nums[i]  i++  j--  } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  if i == size-1 {  res = append(res, node.Val)  }  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 {  res := []float64{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  sum := 0  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  sum += node.Val  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, float64(sum)/float64(size))  }  return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int {  res := [][]int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  level := []int{}  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  level = append(level, node.Val)  for _,child := range node.Children {  if child != nil {  queue = append(queue, child)  }  }  }  res = append(res, level)  }  return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  max := queue[0].Val  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  if node.Val  max {  max = node.Val  }  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, max)  }  return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node {  if root == nil {  return root  }  queue := []*Node{root}  for len(queue)  0 {  size := len(queue)  var pre *Node = nil  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  if pre != nil {  pre.Next = node  }  pre = node  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { \tif root == nil {  return root  }  queue := []*Node{root}  for len(queue)  0 {  size := len(queue)  var pre *Node = nil  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  if pre != nil {  pre.Next = node  }  pre = node  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int {  if root == nil {  return 0  }  depth := 0  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  depth++  }  return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int {  if root == nil {  return 0  }  depth := 0  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  depth++  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  if node.Left == nil \u0026\u0026 node.Right == nil {  return depth  }  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode {  if root != nil {  root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)  }  return root }  // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode {  if root == nil {  return root  }  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  node.Left, node.Right = node.Right, node.Left  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool {  return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool {  if left == nil \u0026\u0026 right == nil {  return true;  };  if left == nil || right == nil {  return false;  };  if left.Val != right.Val {  return false;  }  return defs(left.Left, right.Right) \u0026\u0026 defs(right.Left, left.Right); }  // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool {  queue := []*TreeNode{root.Left, root.Right}  for len(queue)  0 {  left := queue[0]  right := queue[1]  queue = queue[2:]  if left == nil \u0026\u0026 right == nil {  continue  }  if left == nil || right == nil || left.Val != right.Val {  return false  }  queue = append(queue, left.Left, right.Right, left.Right, right.Left)  }  return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int {  if root == nil {  return 0  }  depth := 0  queue := []*Node{root}  for len(queue)  0 {  size := len(queue)  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  for _, child := range node.Children {  queue = append(queue, child)  }  }  depth++  }  return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int {  if root == nil {  return 0  }  count := 0  queue := []*TreeNode{root}  for len(queue)  0 {  size := len(queue)  for i := 0; i size; i++ {  node := queue[0]  queue = queue[1:]  count++  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool {  return getHeight(root) != -1 }  func getHeight(root *TreeNode) int {  if root == nil {  return 0  }  left := getHeight(root.Left)  right := getHeight(root.Right)  if left == -1 || right == -1 || math.Abs(float64(left-right))  1 {  return -1  }  return int(math.Max(float64(left), float64(right))) + 1  } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string {  res := []string{}  var travel func(root *TreeNode, s string)  travel = func(root *TreeNode, s string) {  if root.Left == nil \u0026\u0026 root.Right == nil {  res = append(res, s + strconv.Itoa(root.Val))  return  }  s += strconv.Itoa(root.Val) + \"-\"  if root.Left != nil {  travel(root.Left, s)  }  if root.Right != nil {  travel(root.Right, s)  }  }  travel(root, \"\")  return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool {  if p == nil \u0026\u0026 q == nil {  return true  }  if p == nil || q == nil || p.Val != q.Val {  return false  }  return isSameTree(p.Left, q.Left) \u0026\u0026 isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int {  if root == nil {  return 0  }  sum := 0  if root.Left != nil \u0026\u0026 root.Left.Left == nil \u0026\u0026 root.Left.Right == nil {  sum += root.Left.Val  }  sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)  return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int {  maxLen := 1  maxValue := root.Val  var travel func(root *TreeNode, length int)  travel = func(root *TreeNode, length int) {  if root.Left == nil \u0026\u0026 root.Right == nil {  if (length  maxLen) {  maxLen = length  maxValue = root.Val  return  }  }  if root.Left != nil {  travel(root.Left, length+1)  }  if root.Right != nil {  travel(root.Right, length+1)  }  }  travel(root, 1)  return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool {  if root == nil {  return false  }  if targetSum == root.Val \u0026\u0026 root.Left == nil \u0026\u0026 root.Right == nil {  return true  }  return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int {  res := [][]int{}  var travel func(root *TreeNode, targetSum int, path []int)  travel = func(root *TreeNode, targetSum int, path []int) {  if root == nil {  return  }  path = append(path, root.Val)  if root.Left == nil \u0026\u0026 root.Right == nil \u0026\u0026 root.Val == targetSum {  p := make([]int, len(path))  copy(p, path) // 注意此处，需要复制一个slice  res = append(res, p)  return  }  if root.Left != nil {  travel(root.Left, targetSum - root.Val, path)  }  if root.Right != nil {  travel(root.Right, targetSum - root.Val, path)  }  }  travel(root, targetSum, []int{})  return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode {  n := len(inorder)  if n  0 {  return nil  }  mid := postorder[n-1]  index := 0  for i := 0; i n; i++ { // 找到root节点在inorder中的下标  if inorder[i] == mid {  index = i  break  }  }  root := \u0026TreeNode {  Val: mid,  Left: buildTree(inorder[:index], postorder[:index]),  Right: buildTree(inorder[index+1:], postorder[index:n-1]),  }  return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode {  n := len(inorder)  if n  0 {  return nil  }  mid := preorder[0]  index := 0  for i := 0; i n; i++ { // 找到root节点在inorder中的下标  if inorder[i] == mid {  index = i  break  }  }  root := \u0026TreeNode {  Val: mid,  Left: buildTree(preorder[1:index+1], inorder[:index]),  Right: buildTree(preorder[index+1:], inorder[index+1:]),  }  return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode {  if len(nums)  0 {  return nil  }  maxNum := nums[0]  maxIndex := 0  for i, v := range nums {  if v  maxNum {  maxNum = v  maxIndex = i  }  }  return \u0026TreeNode {  Val: maxNum,  Left: constructMaximumBinaryTree(nums[:maxIndex]),  Right: constructMaximumBinaryTree(nums[maxIndex+1:]),  } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {  if root1 == nil \u0026\u0026 root2 == nil {  return nil  }  root := \u0026TreeNode {}  if root1 == nil {  root = root2  } else if root2 == nil {  root = root1  } else {  root = \u0026TreeNode {  Val: root1.Val+root2.Val,  Left: mergeTrees(root1.Left, root2.Left),  Right: mergeTrees(root1.Right, root2.Right),  }  }  return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode {  if root == nil {  return nil  }  if root.Val == val {  return root  }  node := searchBST(root.Left, val)  if node != nil {  return node  }  node = searchBST(root.Right, val)  return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool {  var verify func(root *TreeNode, min, max int64) bool  verify = func(root *TreeNode, min, max int64) bool {  if root == nil {  return true  }   if min = int64(root.Val) || max  int64(root.Val) {  return false  }  // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true  return verify(root.Right,int64(root.Val),max) \u0026\u0026 verify(root.Left,min,int64(root.Val))  }  return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int {  var dfs func(node *TreeNode)  min := 100000  pre := -1  dfs = func(node *TreeNode) {  if node == nil {  return  }  dfs(node.Left)  if pre != -1 \u0026\u0026 node.Val - pre min {  min = node.Val - pre  }  pre = node.Val  dfs(node.Right)  }  dfs(root)  return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int {  var dfs func(node *TreeNode)  res := []int{}  maxCount := 0  count := 0  cur := 0  dfs = func(node *TreeNode) {  if node == nil {  return  }  dfs(node.Left)  if node.Val == cur {  count++  } else {  count = 1  }  cur = node.Val  if count  maxCount {  maxCount = count  res = []int{}  }  if count == maxCount {  res = append(res, cur)  }  dfs(node.Right)  }  dfs(root)  return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {  if root == nil {  return nil  }  if root == p || root == q {  return root  }  left := lowestCommonAncestor(root.Left, p, q)  right := lowestCommonAncestor(root.Right, p, q)  if left != nil \u0026\u0026 right != nil {  return root  }  if left != nil {  return left  }  if right != nil {  return right  }  return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { \tif root == nil {  return nil  }  if root == q || root == p || (root.Val = p.Val \u0026\u0026 root.Val  q.Val) || (root.Val  p.Val \u0026\u0026 root.Val = q.Val) {  return root  }  if root.Val  p.Val \u0026\u0026 root.Val  q.Val {  return lowestCommonAncestor(root.Left, p, q)  }  if root.Val p.Val \u0026\u0026 root.Val q.Val {  return lowestCommonAncestor(root.Right, p, q)  }  return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode {  if root == nil {  return \u0026TreeNode{  Val: val,  }  }  cur := root  for cur != nil {  if cur.Val  val {  if cur.Left == nil {  cur.Left = \u0026TreeNode{  Val: val,  }  return root  }  cur = cur.Left  } else {  if cur.Right == nil {  cur.Right = \u0026TreeNode{  Val: val,  }  return root  }  cur = cur.Right  }  }  return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode {  if root == nil {  return nil  }  if root.Val == key {  if root.Left == nil \u0026\u0026 root.Right == nil {  return nil  } else if root.Right == nil {  return root.Left  } else if root.Left == nil {  return root.Right  } else {  cur := root.Right  for cur.Left != nil {  cur = cur.Left  }  cur.Left = root.Left  return root.Right  }  } else if root.Val  key {  root.Left = deleteNode(root.Left, key)  } else {  root.Right = deleteNode(root.Right, key)  }  return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode {  if root == nil {  return nil  } else if root.Val low {  return trimBST(root.Right, low, high)  } else if root.Val  high {  return trimBST(root.Left, low, high)  } else {  root.Left = trimBST(root.Left, low, high)  root.Right = trimBST(root.Right, low, high)  }  return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode {  n := len(nums)  if n == 0 {  return nil  }  mid := n/2  root := \u0026TreeNode {  Val: nums[mid],  Left: sortedArrayToBST(nums[:mid]),  Right: sortedArrayToBST(nums[mid+1:]),  }  return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode {  sum := 0  var dfs func(node *TreeNode)  dfs = func(node *TreeNode) {  if node == nil {  return  }  dfs(node.Right)  node.Val = sum + node.Val  sum = node.Val  dfs(node.Left)  }  dfs(root)  return root } ","wordCount":"3157","inLanguage":"en","datePublished":"2022-05-21T21:53:39+08:00","dateModified":"2022-05-21T21:53:39+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/"},"publisher":{"@type":"Organization","name":"My Favorite","logo":{"@type":"ImageObject","url":"https://oyzg.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://oyzg.github.io/ accesskey=h title="My Favorite (Alt + H)">My Favorite</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://oyzg.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://oyzg.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://oyzg.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://oyzg.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://oyzg.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>二叉树</h1><div class=post-meta>May 21, 2022&nbsp;·&nbsp;15 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=二叉树>二叉树</a><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a><ul><li><a href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86 aria-label=二叉树的遍历>二叉树的遍历</a><ul><li><a href=#%e9%80%92%e5%bd%92%e9%81%8d%e5%8e%86 aria-label=递归遍历>递归遍历</a></li><li><a href=#%e8%bf%ad%e4%bb%a3%e9%81%8d%e5%8e%86 aria-label=迭代遍历>迭代遍历</a></li><li><a href=#%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label=层序遍历>层序遍历</a><ul><li><a href=#102-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcodecnproblemsbinary-tree-level-order-traversal aria-label="[102. 二叉树的层序遍历]"><a href=https://leetcode.cn/problems/binary-tree-level-order-traversal/>[102. 二叉树的层序遍历]</a></a></li><li><a href=#107%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86ii aria-label=107.二叉树的层次遍历II><a href>107.二叉树的层次遍历II</a></a></li><li><a href=#199%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%8f%b3%e8%a7%86%e5%9b%be aria-label=199.二叉树的右视图><a href>199.二叉树的右视图</a></a></li><li><a href=#637-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%b9%b3%e5%9d%87%e5%80%bchttpsleetcodecnproblemsaverage-of-levels-in-binary-tree aria-label="637. 二叉树的层平均值"><a href=https://leetcode.cn/problems/average-of-levels-in-binary-tree/>637. 二叉树的层平均值</a></a></li><li><a href=#429-n-%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcodecnproblemsn-ary-tree-level-order-traversal aria-label="429. N 叉树的层序遍历"><a href=https://leetcode.cn/problems/n-ary-tree-level-order-traversal/>429. N 叉树的层序遍历</a></a></li><li><a href=#515-%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%a0%91%e8%a1%8c%e4%b8%ad%e6%89%be%e6%9c%80%e5%a4%a7%e5%80%bchttpsleetcodecnproblemsfind-largest-value-in-each-tree-row aria-label="515. 在每个树行中找最大值"><a href=https://leetcode.cn/problems/find-largest-value-in-each-tree-row/>515. 在每个树行中找最大值</a></a></li><li><a href=#116-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node aria-label="116. 填充每个节点的下一个右侧节点指针"><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/>116. 填充每个节点的下一个右侧节点指针</a></a></li><li><a href=#117-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88-iihttpsleetcodecnproblemspopulating-next-right-pointers-in-each-node-ii aria-label="117. 填充每个节点的下一个右侧节点指针 II"><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/>117. 填充每个节点的下一个右侧节点指针 II</a></a></li><li><a href=#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6httpsleetcodecnproblemsmaximum-depth-of-binary-tree aria-label="104. 二叉树的最大深度"><a href=https://leetcode.cn/problems/maximum-depth-of-binary-tree/>104. 二叉树的最大深度</a></a></li><li><a href=#111-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e6%b7%b1%e5%ba%a6httpsleetcodecnproblemsminimum-depth-of-binary-tree aria-label="111. 二叉树的最小深度"><a href=https://leetcode.cn/problems/minimum-depth-of-binary-tree/>111. 二叉树的最小深度</a></a></li></ul></li></ul></li></ul></li><li><a href=#%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95%e9%a2%98 aria-label=常见算法题>常见算法题</a><ul><ul><li><a href=#226-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsinvert-binary-tree aria-label="226. 翻转二叉树"><a href=https://leetcode.cn/problems/invert-binary-tree/>226. 翻转二叉树</a></a></li><li><a href=#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemssymmetric-tree aria-label="101. 对称二叉树"><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a></a></li><li><a href=#559-n-%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6httpsleetcodecnproblemsmaximum-depth-of-n-ary-tree aria-label="559. N 叉树的最大深度"><a href=https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/>559. N 叉树的最大深度</a></a></li><li><a href=#222-%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0httpsleetcodecnproblemscount-complete-tree-nodes aria-label="222. 完全二叉树的节点个数"><a href=https://leetcode.cn/problems/count-complete-tree-nodes/>222. 完全二叉树的节点个数</a></a></li><li><a href=#257-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%89%80%e6%9c%89%e8%b7%af%e5%be%84httpsleetcodecnproblemsbinary-tree-paths aria-label="257. 二叉树的所有路径"><a href=https://leetcode.cn/problems/binary-tree-paths/>257. 二叉树的所有路径</a></a></li><li><a href=#100-%e7%9b%b8%e5%90%8c%e7%9a%84%e6%a0%91httpsleetcodecnproblemssame-tree aria-label="100. 相同的树"><a href=https://leetcode.cn/problems/same-tree/>100. 相同的树</a></a></li><li><a href=#404-%e5%b7%a6%e5%8f%b6%e5%ad%90%e4%b9%8b%e5%92%8chttpsleetcodecnproblemssum-of-left-leaves aria-label="404. 左叶子之和"><a href=https://leetcode.cn/problems/sum-of-left-leaves/>404. 左叶子之和</a></a></li><li><a href=#513-%e6%89%be%e6%a0%91%e5%b7%a6%e4%b8%8b%e8%a7%92%e7%9a%84%e5%80%bchttpsleetcodecnproblemsfind-bottom-left-tree-value aria-label="513. 找树左下角的值"><a href=https://leetcode.cn/problems/find-bottom-left-tree-value/>513. 找树左下角的值</a></a></li><li><a href=#112-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8chttpsleetcodecnproblemspath-sum aria-label="112. 路径总和"><a href=https://leetcode.cn/problems/path-sum/>112. 路径总和</a></a></li><li><a href=#113-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-iihttpsleetcodecnproblemspath-sum-ii aria-label="113. 路径总和 II"><a href=https://leetcode.cn/problems/path-sum-ii/>113. 路径总和 II</a></a></li><li><a href=#106-%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal aria-label="106. 从中序与后序遍历序列构造二叉树"><a href=https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106. 从中序与后序遍历序列构造二叉树</a></a></li><li><a href=#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal aria-label="105. 从前序与中序遍历序列构造二叉树"><a href=https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. 从前序与中序遍历序列构造二叉树</a></a></li><li><a href=#654-%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsmaximum-binary-tree aria-label="654. 最大二叉树"><a href=https://leetcode.cn/problems/maximum-binary-tree/>654. 最大二叉树</a></a></li><li><a href=#617-%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsmerge-two-binary-trees aria-label="617. 合并二叉树"><a href=https://leetcode.cn/problems/merge-two-binary-trees/>617. 合并二叉树</a></a></li><li><a href=#700-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2httpsleetcodecnproblemssearch-in-a-binary-search-tree aria-label="700. 二叉搜索树中的搜索"><a href=https://leetcode.cn/problems/search-in-a-binary-search-tree/>700. 二叉搜索树中的搜索</a></a></li><li><a href=#98-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemsvalidate-binary-search-tree aria-label="98. 验证二叉搜索树"><a href=https://leetcode.cn/problems/validate-binary-search-tree/>98. 验证二叉搜索树</a></a></li><li><a href=#530-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e7%bb%9d%e5%af%b9%e5%b7%aehttpsleetcodecnproblemsminimum-absolute-difference-in-bst aria-label="530. 二叉搜索树的最小绝对差"><a href=https://leetcode.cn/problems/minimum-absolute-difference-in-bst/>530. 二叉搜索树的最小绝对差</a></a></li><li><a href=#501-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e4%bc%97%e6%95%b0httpsleetcodecnproblemsfind-mode-in-binary-search-tree aria-label="501. 二叉搜索树中的众数"><a href=https://leetcode.cn/problems/find-mode-in-binary-search-tree/>501. 二叉搜索树中的众数</a></a></li><li><a href=#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree aria-label="236. 二叉树的最近公共祖先"><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>236. 二叉树的最近公共祖先</a></a></li><li><a href=#701-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9chttpsleetcodecnproblemsinsert-into-a-binary-search-tree aria-label="701. 二叉搜索树中的插入操作"><a href=https://leetcode.cn/problems/insert-into-a-binary-search-tree/>701. 二叉搜索树中的插入操作</a></a></li><li><a href=#450-%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9httpsleetcodecnproblemsdelete-node-in-a-bst aria-label="450. 删除二叉搜索树中的节点"><a href=https://leetcode.cn/problems/delete-node-in-a-bst/>450. 删除二叉搜索树中的节点</a></a></li><li><a href=#669-%e4%bf%ae%e5%89%aa%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemstrim-a-binary-search-tree aria-label="669. 修剪二叉搜索树"><a href=https://leetcode.cn/problems/trim-a-binary-search-tree/>669. 修剪二叉搜索树</a></a></li><li><a href=#108-%e5%b0%86%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemsconvert-sorted-array-to-binary-search-tree aria-label="108. 将有序数组转换为二叉搜索树"><a href=https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/>108. 将有序数组转换为二叉搜索树</a></a></li><li><a href=#538-%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%b4%af%e5%8a%a0%e6%a0%91httpsleetcodecnproblemsconvert-bst-to-greater-tree aria-label="538. 把二叉搜索树转换为累加树"><a href=https://leetcode.cn/problems/convert-bst-to-greater-tree/>538. 把二叉搜索树转换为累加树</a></a></li></ul></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=二叉树>二叉树<a hidden class=anchor aria-hidden=true href=#二叉树>#</a></h1><h2 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h2><p>先来看看<strong>定义</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeNode</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val<span style=color:#f92672>;</span> <span style=color:#75715e>// 值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	TreeNode left<span style=color:#f92672>;</span> <span style=color:#75715e>// 左节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	TreeNode right<span style=color:#f92672>;</span><span style=color:#75715e>// 右节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	TreeNode<span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>  	TreeNode<span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> val<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>val</span> <span style=color:#f92672>=</span> val<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TreeNode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Val</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Left</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。</p><p>再来看看二叉树的<strong>存储方式</strong></p><p>二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果</p><p><img src=/images/%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20220522102758379.png alt=image-20220522102758379></p><p>再来看看二叉树的<strong>遍历顺序</strong>：</p><p>二叉树的遍历顺序有两种：</p><ul><li>深度优先遍历（DFS）<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li><li>广度优先遍历（BFS）</li></ul><p>深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现</p><p>广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的</p><p>最后来看看几个特别的二叉树：</p><p><strong>满二叉树</strong>：</p><p><img src=/images/%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20220522103534130.png alt=image-20220522103534130></p><p><strong>完全二叉树</strong>：</p><p>完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况</p><p><strong>二叉搜索树</strong>：</p><p>左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的</p><p><strong>平衡二叉搜索树（AVL）</strong>：</p><p>在二叉搜索树的基础上，左右子树的高度差不超过1</p><h3 id=二叉树的遍历>二叉树的遍历<a hidden class=anchor aria-hidden=true href=#二叉树的遍历>#</a></h3><p><a href=https://leetcode.cn/problems/binary-tree-preorder-traversal/>前序遍历</a></p><p><a href=https://leetcode.cn/problems/binary-tree-inorder-traversal/>中序遍历</a></p><p><a href=https://leetcode.cn/problems/binary-tree-postorder-traversal/>后序遍历</a></p><h4 id=递归遍历>递归遍历<a hidden class=anchor aria-hidden=true href=#递归遍历>#</a></h4><p>递归三要素：</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Definition for a binary tree node.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * type TreeNode struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Val int
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Left *TreeNode
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Right *TreeNode
</span></span></span><span style=display:flex><span><span style=color:#75715e> * }
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 前序遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>preorder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>preorder</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>preorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>preorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>preorder</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 中序遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inorder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inorder</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>inorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>inorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inorder</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 后序遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>postorder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postorder</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>postorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>postorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postorder</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=迭代遍历>迭代遍历<a hidden class=anchor aria-hidden=true href=#迭代遍历>#</a></h4><p>迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 前序遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 中序遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>cur</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 后序遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>a</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>l</span> &lt; <span style=color:#a6e22e>r</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>l</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>] = <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>l</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>l</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>r</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外迭代法还有统一的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> type Element struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e>    // 元素保管的值
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Value interface{}
</span></span></span><span style=display:flex><span><span style=color:#75715e>    // 内含隐藏或非导出字段
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>func (l *List) Back() *Element 
</span></span></span><span style=display:flex><span><span style=color:#75715e>前序遍历：中左右
</span></span></span><span style=display:flex><span><span style=color:#75715e>压栈顺序：右左中
</span></span></span><span style=display:flex><span><span style=color:#75715e> **/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>()<span style=color:#75715e>//栈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>res</span><span style=color:#f92672>:=</span>[]<span style=color:#66d9ef>int</span>{}<span style=color:#75715e>//结果集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Len</span>()&gt;<span style=color:#ae81ff>0</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//弹出元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{<span style=color:#75715e>// 如果为空，则表明是需要处理中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>e</span>=<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()<span style=color:#75715e>//弹出元素（即中间节点）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//删除中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>node</span>=<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>=append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)<span style=color:#75715e>//将中间节点加入到结果集中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>continue</span><span style=color:#75715e>//继续弹出栈中下一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//压栈顺序：右左中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>)<span style=color:#75715e>//中间节点压栈后再压入nil作为中间节点的标志符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//中序遍历：左中右
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>//压栈顺序：右中左
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span><span style=color:#f92672>:=</span><span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>()<span style=color:#75715e>//栈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>res</span><span style=color:#f92672>:=</span>[]<span style=color:#66d9ef>int</span>{}<span style=color:#75715e>//结果集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Len</span>()&gt;<span style=color:#ae81ff>0</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{<span style=color:#75715e>// 如果为空，则表明是需要处理中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>e</span>=<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()<span style=color:#75715e>//弹出元素（即中间节点）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//删除中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>node</span>=<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>=append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)<span style=color:#75715e>//将中间节点加入到结果集中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>continue</span><span style=color:#75715e>//继续弹出栈中下一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//压栈顺序：右中左
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>)<span style=color:#75715e>//中间节点压栈后再压入nil作为中间节点的标志符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//后续遍历：左右中
</span></span></span><span style=display:flex><span><span style=color:#75715e>//压栈顺序：中右左
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>()<span style=color:#75715e>//栈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>res</span><span style=color:#f92672>:=</span>[]<span style=color:#66d9ef>int</span>{}<span style=color:#75715e>//结果集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Len</span>()&gt;<span style=color:#ae81ff>0</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{<span style=color:#75715e>// 如果为空，则表明是需要处理中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>e</span>=<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()<span style=color:#75715e>//弹出元素（即中间节点）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//删除中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>node</span>=<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>=append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)<span style=color:#75715e>//将中间节点加入到结果集中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>continue</span><span style=color:#75715e>//继续弹出栈中下一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//压栈顺序：中右左
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>)<span style=color:#75715e>//中间节点压栈后再压入nil作为中间节点的标志符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=层序遍历>层序遍历<a hidden class=anchor aria-hidden=true href=#层序遍历>#</a></h4><h5 id=102-二叉树的层序遍历httpsleetcodecnproblemsbinary-tree-level-order-traversal><a href=https://leetcode.cn/problems/binary-tree-level-order-traversal/>[102. 二叉树的层序遍历]</a><a hidden class=anchor aria-hidden=true href=#102-二叉树的层序遍历httpsleetcodecnproblemsbinary-tree-level-order-traversal>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrder</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>level</span> = append(<span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=107二叉树的层次遍历ii><a href>107.二叉树的层次遍历II</a><a hidden class=anchor aria-hidden=true href=#107二叉树的层次遍历ii>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 思路：将层次遍历结果反转即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrderBottom</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>level</span> = append(<span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>nums</span> [][]<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>nums</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>j</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>j</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=199二叉树的右视图><a href>199.二叉树的右视图</a><a hidden class=anchor aria-hidden=true href=#199二叉树的右视图>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 思路：取右视图即取层次遍历结果每层的最后一个节点即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rightSideView</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=637-二叉树的层平均值httpsleetcodecnproblemsaverage-of-levels-in-binary-tree><a href=https://leetcode.cn/problems/average-of-levels-in-binary-tree/>637. 二叉树的层平均值</a><a hidden class=anchor aria-hidden=true href=#637-二叉树的层平均值httpsleetcodecnproblemsaverage-of-levels-in-binary-tree>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS：每层取平均值即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>averageOfLevels</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>float64</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>float64</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, float64(<span style=color:#a6e22e>sum</span>)<span style=color:#f92672>/</span>float64(<span style=color:#a6e22e>size</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=429-n-叉树的层序遍历httpsleetcodecnproblemsn-ary-tree-level-order-traversal><a href=https://leetcode.cn/problems/n-ary-tree-level-order-traversal/>429. N 叉树的层序遍历</a><a hidden class=anchor aria-hidden=true href=#429-n-叉树的层序遍历httpsleetcodecnproblemsn-ary-tree-level-order-traversal>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrder</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>level</span> = append(<span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>,<span style=color:#a6e22e>child</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Children</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>child</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=515-在每个树行中找最大值httpsleetcodecnproblemsfind-largest-value-in-each-tree-row><a href=https://leetcode.cn/problems/find-largest-value-in-each-tree-row/>515. 在每个树行中找最大值</a><a hidden class=anchor aria-hidden=true href=#515-在每个树行中找最大值httpsleetcodecnproblemsfind-largest-value-in-each-tree-row>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>largestValues</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>max</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>max</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>max</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>max</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=116-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/>116. 填充每个节点的下一个右侧节点指针</a><a hidden class=anchor aria-hidden=true href=#116-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pre</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=117-填充每个节点的下一个右侧节点指针-iihttpsleetcodecnproblemspopulating-next-right-pointers-in-each-node-ii><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/>117. 填充每个节点的下一个右侧节点指针 II</a><a hidden class=anchor aria-hidden=true href=#117-填充每个节点的下一个右侧节点指针-iihttpsleetcodecnproblemspopulating-next-right-pointers-in-each-node-ii>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 同上 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TODO：其他解法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pre</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree><a href=https://leetcode.cn/problems/maximum-depth-of-binary-tree/>104. 二叉树的最大深度</a><a hidden class=anchor aria-hidden=true href=#104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=111-二叉树的最小深度httpsleetcodecnproblemsminimum-depth-of-binary-tree><a href=https://leetcode.cn/problems/minimum-depth-of-binary-tree/>111. 二叉树的最小深度</a><a hidden class=anchor aria-hidden=true href=#111-二叉树的最小深度httpsleetcodecnproblemsminimum-depth-of-binary-tree>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>minDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }   
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=常见算法题>常见算法题<a hidden class=anchor aria-hidden=true href=#常见算法题>#</a></h2><h4 id=226-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree><a href=https://leetcode.cn/problems/invert-binary-tree/>226. 翻转二叉树</a><a hidden class=anchor aria-hidden=true href=#226-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归，左右节点互换即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>), <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 迭代法，使用BFS即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }   
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=101-对称二叉树httpsleetcodecnproblemssymmetric-tree><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a><a hidden class=anchor aria-hidden=true href=#101-对称二叉树httpsleetcodecnproblemssymmetric-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSymmetric</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 将左右节点作为参数分别传入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>left</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Right</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Right</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSymmetric</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=559-n-叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-n-ary-tree><a href=https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/>559. N 叉树的最大深度</a><a hidden class=anchor aria-hidden=true href=#559-n-叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-n-ary-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>child</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Children</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>child</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=222-完全二叉树的节点个数httpsleetcodecnproblemscount-complete-tree-nodes><a href=https://leetcode.cn/problems/count-complete-tree-nodes/>222. 完全二叉树的节点个数</a><a hidden class=anchor aria-hidden=true href=#222-完全二叉树的节点个数httpsleetcodecnproblemscount-complete-tree-nodes>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>countNodes</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode.cn/problems/balanced-binary-tree/>110. 平衡二叉树</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isBalanced</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span>) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Abs</span>(float64(<span style=color:#a6e22e>left</span><span style=color:#f92672>-</span><span style=color:#a6e22e>right</span>)) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Max</span>(float64(<span style=color:#a6e22e>left</span>), float64(<span style=color:#a6e22e>right</span>))) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=257-二叉树的所有路径httpsleetcodecnproblemsbinary-tree-paths><a href=https://leetcode.cn/problems/binary-tree-paths/>257. 二叉树的所有路径</a><a hidden class=anchor aria-hidden=true href=#257-二叉树的所有路径httpsleetcodecnproblemsbinary-tree-paths>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>binaryTreePaths</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>travel</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;-&gt;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=100-相同的树httpsleetcodecnproblemssame-tree><a href=https://leetcode.cn/problems/same-tree/>100. 相同的树</a><a hidden class=anchor aria-hidden=true href=#100-相同的树httpsleetcodecnproblemssame-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSameTree</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>isSameTree</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Left</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>isSameTree</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=404-左叶子之和httpsleetcodecnproblemssum-of-left-leaves><a href=https://leetcode.cn/problems/sum-of-left-leaves/>404. 左叶子之和</a><a hidden class=anchor aria-hidden=true href=#404-左叶子之和httpsleetcodecnproblemssum-of-left-leaves>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumOfLeftLeaves</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>sumOfLeftLeaves</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>sumOfLeftLeaves</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=513-找树左下角的值httpsleetcodecnproblemsfind-bottom-left-tree-value><a href=https://leetcode.cn/problems/find-bottom-left-tree-value/>513. 找树左下角的值</a><a hidden class=anchor aria-hidden=true href=#513-找树左下角的值httpsleetcodecnproblemsfind-bottom-left-tree-value>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findBottomLeftValue</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxLen</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>travel</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>length</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>length</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>length</span> &gt; <span style=color:#a6e22e>maxLen</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>maxLen</span> = <span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>maxValue</span> = <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>length</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>length</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>maxValue</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=112-路径总和httpsleetcodecnproblemspath-sum><a href=https://leetcode.cn/problems/path-sum/>112. 路径总和</a><a hidden class=anchor aria-hidden=true href=#112-路径总和httpsleetcodecnproblemspath-sum>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hasPathSum</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hasPathSum</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>hasPathSum</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=113-路径总和-iihttpsleetcodecnproblemspath-sum-ii><a href=https://leetcode.cn/problems/path-sum-ii/>113. 路径总和 II</a><a hidden class=anchor aria-hidden=true href=#113-路径总和-iihttpsleetcodecnproblemspath-sum-ii>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pathSum</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>travel</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>path</span> []<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>path</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>path</span> = append(<span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>targetSum</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>path</span>))
</span></span><span style=display:flex><span>            copy(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>path</span>) <span style=color:#75715e>// 注意此处，需要复制一个slice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>, <span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>, <span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>targetSum</span>, []<span style=color:#66d9ef>int</span>{})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=106-从中序与后序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal><a href=https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106. 从中序与后序遍历序列构造二叉树</a><a hidden class=anchor aria-hidden=true href=#106-从中序与后序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>inorder</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>postorder</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>inorder</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>postorder</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>// 找到root节点在inorder中的下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>mid</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>mid</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>inorder</span>[:<span style=color:#a6e22e>index</span>], <span style=color:#a6e22e>postorder</span>[:<span style=color:#a6e22e>index</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#a6e22e>postorder</span>[<span style=color:#a6e22e>index</span>:<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=105-从前序与中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal><a href=https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. 从前序与中序遍历序列构造二叉树</a><a hidden class=anchor aria-hidden=true href=#105-从前序与中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>preorder</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>inorder</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>inorder</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>preorder</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>// 找到root节点在inorder中的下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>mid</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>mid</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>preorder</span>[<span style=color:#ae81ff>1</span>:<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>inorder</span>[:<span style=color:#a6e22e>index</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>preorder</span>[<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=654-最大二叉树httpsleetcodecnproblemsmaximum-binary-tree><a href=https://leetcode.cn/problems/maximum-binary-tree/>654. 最大二叉树</a><a hidden class=anchor aria-hidden=true href=#654-最大二叉树httpsleetcodecnproblemsmaximum-binary-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>constructMaximumBinaryTree</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>nums</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxNum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxIndex</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#a6e22e>maxNum</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxNum</span> = <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxIndex</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>maxNum</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>constructMaximumBinaryTree</span>(<span style=color:#a6e22e>nums</span>[:<span style=color:#a6e22e>maxIndex</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>constructMaximumBinaryTree</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>maxIndex</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=617-合并二叉树httpsleetcodecnproblemsmerge-two-binary-trees><a href=https://leetcode.cn/problems/merge-two-binary-trees/>617. 合并二叉树</a><a hidden class=anchor aria-hidden=true href=#617-合并二叉树httpsleetcodecnproblemsmerge-two-binary-trees>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>root1</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>root2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root2</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span> = <span style=color:#a6e22e>root2</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root2</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span> = <span style=color:#a6e22e>root1</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>root1</span>.<span style=color:#a6e22e>Val</span><span style=color:#f92672>+</span><span style=color:#a6e22e>root2</span>.<span style=color:#a6e22e>Val</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>root1</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root2</span>.<span style=color:#a6e22e>Left</span>),
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>root1</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>root2</span>.<span style=color:#a6e22e>Right</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=700-二叉搜索树中的搜索httpsleetcodecnproblemssearch-in-a-binary-search-tree><a href=https://leetcode.cn/problems/search-in-a-binary-search-tree/>700. 二叉搜索树中的搜索</a><a hidden class=anchor aria-hidden=true href=#700-二叉搜索树中的搜索httpsleetcodecnproblemssearch-in-a-binary-search-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>searchBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>searchBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>  <span style=color:#a6e22e>node</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>searchBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=98-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree><a href=https://leetcode.cn/problems/validate-binary-search-tree/>98. 验证二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#98-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isValidBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>verify</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>min</span>, <span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>verify</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>min</span>, <span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>min</span> <span style=color:#f92672>&gt;=</span> int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>max</span> <span style=color:#f92672>&lt;=</span> int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>verify</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>,int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>),<span style=color:#a6e22e>max</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>verify</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>,<span style=color:#a6e22e>min</span>,int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>verify</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MinInt64</span>, <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MaxInt64</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=530-二叉搜索树的最小绝对差httpsleetcodecnproblemsminimum-absolute-difference-in-bst><a href=https://leetcode.cn/problems/minimum-absolute-difference-in-bst/>530. 二叉搜索树的最小绝对差</a><a hidden class=anchor aria-hidden=true href=#530-二叉搜索树的最小绝对差httpsleetcodecnproblemsminimum-absolute-difference-in-bst>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getMinimumDifference</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>min</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>100000</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pre</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>pre</span> &lt; <span style=color:#a6e22e>min</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>min</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>pre</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>min</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=501-二叉搜索树中的众数httpsleetcodecnproblemsfind-mode-in-binary-search-tree><a href=https://leetcode.cn/problems/find-mode-in-binary-search-tree/>501. 二叉搜索树中的众数</a><a hidden class=anchor aria-hidden=true href=#501-二叉搜索树中的众数httpsleetcodecnproblemsfind-mode-in-binary-search-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findMode</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>cur</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> &gt; <span style=color:#a6e22e>maxCount</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxCount</span> = <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>maxCount</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>cur</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>236. 二叉树的最近公共祖先</a><a hidden class=anchor aria-hidden=true href=#236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>left</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>right</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/>235. 二叉搜索树的最近公共祖先</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &lt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &lt; <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=701-二叉搜索树中的插入操作httpsleetcodecnproblemsinsert-into-a-binary-search-tree><a href=https://leetcode.cn/problems/insert-into-a-binary-search-tree/>701. 二叉搜索树中的插入操作</a><a hidden class=anchor aria-hidden=true href=#701-二叉搜索树中的插入操作httpsleetcodecnproblemsinsert-into-a-binary-search-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>insertIntoBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>val</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>val</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>val</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>val</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=450-删除二叉搜索树中的节点httpsleetcodecnproblemsdelete-node-in-a-bst><a href=https://leetcode.cn/problems/delete-node-in-a-bst/>450. 删除二叉搜索树中的节点</a><a hidden class=anchor aria-hidden=true href=#450-删除二叉搜索树中的节点httpsleetcodecnproblemsdelete-node-in-a-bst>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deleteNode</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>key</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>key</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>deleteNode</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>deleteNode</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=669-修剪二叉搜索树httpsleetcodecnproblemstrim-a-binary-search-tree><a href=https://leetcode.cn/problems/trim-a-binary-search-tree/>669. 修剪二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#669-修剪二叉搜索树httpsleetcodecnproblemstrim-a-binary-search-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>low</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>high</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &lt; <span style=color:#a6e22e>low</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>high</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=108-将有序数组转换为二叉搜索树httpsleetcodecnproblemsconvert-sorted-array-to-binary-search-tree><a href=https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/>108. 将有序数组转换为二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#108-将有序数组转换为二叉搜索树httpsleetcodecnproblemsconvert-sorted-array-to-binary-search-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>],
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span>[:<span style=color:#a6e22e>mid</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=538-把二叉搜索树转换为累加树httpsleetcodecnproblemsconvert-bst-to-greater-tree><a href=https://leetcode.cn/problems/convert-bst-to-greater-tree/>538. 把二叉搜索树转换为累加树</a><a hidden class=anchor aria-hidden=true href=#538-把二叉搜索树转换为累加树httpsleetcodecnproblemsconvert-bst-to-greater-tree>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convertBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)  {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> = <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://oyzg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=https://oyzg.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://oyzg.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></li><li><a href=https://oyzg.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/>二叉树</a></li><li><a href=https://oyzg.github.io/tags/bfs/>BFS</a></li><li><a href=https://oyzg.github.io/tags/dfs/>DFS</a></li></ul><nav class=paginav><a class=prev href=https://oyzg.github.io/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/><span class=title>« Prev Page</span><br><span>回溯算法</span></a>
<a class=next href=https://oyzg.github.io/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/><span class=title>Next Page »</span><br><span>栈和队列</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on twitter" href="https://twitter.com/intent/tweet/?text=%e4%ba%8c%e5%8f%89%e6%a0%91&url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f&hashtags=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%2c%e7%ae%97%e6%b3%95%2c%e9%9d%a2%e8%af%95%2c%e4%ba%8c%e5%8f%89%e6%a0%91%2cBFS%2cDFS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f&title=%e4%ba%8c%e5%8f%89%e6%a0%91&summary=%e4%ba%8c%e5%8f%89%e6%a0%91&source=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f&title=%e4%ba%8c%e5%8f%89%e6%a0%91"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%ba%8c%e5%8f%89%e6%a0%91%20-%20https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on telegram" href="https://telegram.me/share/url?text=%e4%ba%8c%e5%8f%89%e6%a0%91&url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://oyzg.github.io/>My Favorite</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>