<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>贪心算法 | My Favorite</title><meta name=keywords content="数据结构,算法,面试,贪心算法"><meta name=description content="贪心算法相关."><meta name=author content><link rel=canonical href=https://oyzg.github.io/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/><link href=/assets/css/stylesheet.min.d597aab94c71b49b163b6ac67c7958079589ea1a0b7300e8a0014e1d2023b95e.css integrity="sha256-1ZequUxxtJsWO2rGfHlYB5WJ6hoLcwDooAFOHSAjuV4=" rel="preload stylesheet" as=style><link rel=icon href=https://oyzg.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oyzg.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oyzg.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://oyzg.github.io/apple-touch-icon.png><link rel=mask-icon href=https://oyzg.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><meta property="og:title" content="贪心算法"><meta property="og:description" content="贪心算法相关."><meta property="og:type" content="article"><meta property="og:url" content="https://oyzg.github.io/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"><meta property="article:published_time" content="2022-05-28T20:17:52+08:00"><meta property="article:modified_time" content="2022-05-28T20:17:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="贪心算法"><meta name=twitter:description content="贪心算法相关."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Archives","item":"https://oyzg.github.io/archives/"},{"@type":"ListItem","position":2,"name":"贪心算法","item":"https://oyzg.github.io/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"贪心算法","name":"贪心算法","description":"贪心算法相关.","keywords":["数据结构","算法","面试","贪心算法"],"articleBody":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u003c len(g) \u0026\u0026 j \u003c len(s) { if s[j] \u003e= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026\u0026 nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u003c n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u003e 0 \u0026\u0026 pre \u003c= 0) || (cur \u003c 0 \u0026\u0026 pre \u003e= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u003c 0 { sum = 0 } sum += val if sum \u003e res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u003c n; i++ { if prices[i] - prices[i-1] \u003e 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u003e max { // 如果不能跳到这里了 return false } if i + val \u003e max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u003e= n-1 { return count } if i + val \u003e max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u003c n; i++ { if nums[i] \u003c 0 \u0026\u0026 k \u003e 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u003c len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u003c 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u003e= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u003c= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u003c len(ratings); i++ { if ratings[i] \u003e ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u003e= 0; i-- { if ratings[i] \u003e ratings[i+1] \u0026\u0026 candy[i+1]+1 \u003e candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u003c= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u003e 0 \u0026\u0026 money[0] \u003e 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u003e= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u003c people[j][1] } return people[i][0] \u003e people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u003c points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u003e 0 \u0026\u0026 points[i][0] \u003e points[i-1][1] { res++ } else { if i \u003e 0 \u0026\u0026 points[i-1][1] \u003c points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u003c intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u003c len(intervals); i++ { if intervals[i][0] \u003c end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - 'a')] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - 'a')] \u003e cur { cur = end[int(c - 'a')] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u003c intervals[j][0] }) for i := 0; i \u003c len(intervals); i++ { // 更新右边界 if len(res) \u003e 0 \u0026\u0026 res[len(res)-1][1] \u003e= intervals[i][0] { if res[len(res)-1][1] \u003c intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u003e 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u003c len(nums); i++ { if nums[i] \u003e nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u003c= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u003e= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u003c= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u003e start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026\u0026 root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026\u0026 right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","wordCount":"1268","inLanguage":"en","datePublished":"2022-05-28T20:17:52+08:00","dateModified":"2022-05-28T20:17:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://oyzg.github.io/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"My Favorite","logo":{"@type":"ImageObject","url":"https://oyzg.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://oyzg.github.io/ accesskey=h title="My Favorite (Alt + H)">My Favorite</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://oyzg.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://oyzg.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://oyzg.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://oyzg.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://oyzg.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>贪心算法</h1><div class=post-meta>May 28, 2022&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95 aria-label=贪心算法>贪心算法</a><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a></li><li><a href=#%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95%e9%a2%98 aria-label=常见算法题>常见算法题</a><ul><ul><li><a href=#455-%e5%88%86%e5%8f%91%e9%a5%bc%e5%b9%b2httpsleetcodecnproblemsassign-cookies aria-label="455. 分发饼干"><a href=https://leetcode.cn/problems/assign-cookies/>455. 分发饼干</a></a></li><li><a href=#376-%e6%91%86%e5%8a%a8%e5%ba%8f%e5%88%97httpsleetcodecnproblemswiggle-subsequence aria-label="376. 摆动序列"><a href=https://leetcode.cn/problems/wiggle-subsequence/>376. 摆动序列</a></a></li><li><a href=#122-%e4%b9%b0%e5%8d%96%e8%82%a1%e7%a5%a8%e7%9a%84%e6%9c%80%e4%bd%b3%e6%97%b6%e6%9c%ba-iihttpsleetcodecnproblemsbest-time-to-buy-and-sell-stock-ii aria-label="122. 买卖股票的最佳时机 II"><a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/>122. 买卖股票的最佳时机 II</a></a></li><li><a href=#55-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8fhttpsleetcodecnproblemsjump-game aria-label="55. 跳跃游戏"><a href=https://leetcode.cn/problems/jump-game/>55. 跳跃游戏</a></a></li><li><a href=#45-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f-iihttpsleetcodecnproblemsjump-game-ii aria-label="45. 跳跃游戏 II"><a href=https://leetcode.cn/problems/jump-game-ii/>45. 跳跃游戏 II</a></a></li><li><a href=#1005-k-%e6%ac%a1%e5%8f%96%e5%8f%8d%e5%90%8e%e6%9c%80%e5%a4%a7%e5%8c%96%e7%9a%84%e6%95%b0%e7%bb%84%e5%92%8chttpsleetcodecnproblemsmaximize-sum-of-array-after-k-negations aria-label="1005. K 次取反后最大化的数组和"><a href=https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/>1005. K 次取反后最大化的数组和</a></a></li><li><a href=#134-%e5%8a%a0%e6%b2%b9%e7%ab%99httpsleetcodecnproblemsgas-station aria-label="134. 加油站"><a href=https://leetcode.cn/problems/gas-station/>134. 加油站</a></a></li><li><a href=#135-%e5%88%86%e5%8f%91%e7%b3%96%e6%9e%9chttpsleetcodecnproblemscandy aria-label="135. 分发糖果"><a href=https://leetcode.cn/problems/candy/>135. 分发糖果</a></a></li><li><a href=#860-%e6%9f%a0%e6%aa%ac%e6%b0%b4%e6%89%be%e9%9b%b6httpsleetcodecnproblemslemonade-change aria-label="860. 柠檬水找零"><a href=https://leetcode.cn/problems/lemonade-change/>860. 柠檬水找零</a></a></li><li><a href=#406-%e6%a0%b9%e6%8d%ae%e8%ba%ab%e9%ab%98%e9%87%8d%e5%bb%ba%e9%98%9f%e5%88%97httpsleetcodecnproblemsqueue-reconstruction-by-height aria-label="406. 根据身高重建队列"><a href=https://leetcode.cn/problems/queue-reconstruction-by-height/>406. 根据身高重建队列</a></a></li><li><a href=#452-%e7%94%a8%e6%9c%80%e5%b0%91%e6%95%b0%e9%87%8f%e7%9a%84%e7%ae%ad%e5%bc%95%e7%88%86%e6%b0%94%e7%90%83httpsleetcodecnproblemsminimum-number-of-arrows-to-burst-balloons aria-label="452. 用最少数量的箭引爆气球"><a href=https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/>452. 用最少数量的箭引爆气球</a></a></li><li><a href=#435-%e6%97%a0%e9%87%8d%e5%8f%a0%e5%8c%ba%e9%97%b4httpsleetcodecnproblemsnon-overlapping-intervals aria-label="435. 无重叠区间"><a href=https://leetcode.cn/problems/non-overlapping-intervals/>435. 无重叠区间</a></a></li><li><a href=#763-%e5%88%92%e5%88%86%e5%ad%97%e6%af%8d%e5%8c%ba%e9%97%b4httpsleetcodecnproblemspartition-labels aria-label="763. 划分字母区间"><a href=https://leetcode.cn/problems/partition-labels/>763. 划分字母区间</a></a></li><li><a href=#56-%e5%90%88%e5%b9%b6%e5%8c%ba%e9%97%b4httpsleetcodecnproblemsmerge-intervals aria-label="56. 合并区间"><a href=https://leetcode.cn/problems/merge-intervals/>56. 合并区间</a></a></li><li><a href=#738-%e5%8d%95%e8%b0%83%e9%80%92%e5%a2%9e%e7%9a%84%e6%95%b0%e5%ad%97httpsleetcodecnproblemsmonotone-increasing-digits aria-label="738. 单调递增的数字"><a href=https://leetcode.cn/problems/monotone-increasing-digits/>738. 单调递增的数字</a></a></li><li><a href=#714-%e4%b9%b0%e5%8d%96%e8%82%a1%e7%a5%a8%e7%9a%84%e6%9c%80%e4%bd%b3%e6%97%b6%e6%9c%ba%e5%90%ab%e6%89%8b%e7%bb%ad%e8%b4%b9httpsleetcodecnproblemsbest-time-to-buy-and-sell-stock-with-transaction-fee aria-label="714. 买卖股票的最佳时机含手续费"><a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/>714. 买卖股票的最佳时机含手续费</a></a></li><li><a href=#968-%e7%9b%91%e6%8e%a7%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsbinary-tree-cameras aria-label="968. 监控二叉树"><a href=https://leetcode.cn/problems/binary-tree-cameras/>968. 监控二叉树</a></a></li></ul></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=贪心算法>贪心算法<a hidden class=anchor aria-hidden=true href=#贪心算法>#</a></h1><h2 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>所以要使用贪心算法，就得找出贪在哪里</p><p>贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用</p><p>贪心算法一般步骤：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id=常见算法题>常见算法题<a hidden class=anchor aria-hidden=true href=#常见算法题>#</a></h2><h4 id=455-分发饼干httpsleetcodecnproblemsassign-cookies><a href=https://leetcode.cn/problems/assign-cookies/>455. 分发饼干</a><a hidden class=anchor aria-hidden=true href=#455-分发饼干httpsleetcodecnproblemsassign-cookies>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 小饼干喂小胃口，大饼干喂大胃口
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findContentChildren</span>(<span style=color:#a6e22e>g</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>g</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>g</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>j</span> &lt; len(<span style=color:#a6e22e>s</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>g</span>[<span style=color:#a6e22e>i</span>] {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=376-摆动序列httpsleetcodecnproblemswiggle-subsequence><a href=https://leetcode.cn/problems/wiggle-subsequence/>376. 摆动序列</a><a hidden class=anchor aria-hidden=true href=#376-摆动序列httpsleetcodecnproblemswiggle-subsequence>#</a></h4><p><img src=../../static/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.assets/20201124174327597.png alt=376.摆动序列></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>wiggleMaxLength</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pre</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>cur</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>cur</span> &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>cur</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode.cn/problems/maximum-subarray/>53. 最大子数组和</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 如果前面加起来小于0，那我就不加前面的就可以了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxSubArray</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sum</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sum</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sum</span> &gt; <span style=color:#a6e22e>res</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=122-买卖股票的最佳时机-iihttpsleetcodecnproblemsbest-time-to-buy-and-sell-stock-ii><a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/>122. 买卖股票的最佳时机 II</a><a hidden class=anchor aria-hidden=true href=#122-买卖股票的最佳时机-iihttpsleetcodecnproblemsbest-time-to-buy-and-sell-stock-ii>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxProfit</span>(<span style=color:#a6e22e>prices</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>profit</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>prices</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>prices</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>prices</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>profit</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>prices</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>prices</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>profit</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=55-跳跃游戏httpsleetcodecnproblemsjump-game><a href=https://leetcode.cn/problems/jump-game/>55. 跳跃游戏</a><a hidden class=anchor aria-hidden=true href=#55-跳跃游戏httpsleetcodecnproblemsjump-game>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>canJump</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>max</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 最大的覆盖范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &gt; <span style=color:#a6e22e>max</span> { <span style=color:#75715e>// 如果不能跳到这里了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>val</span> &gt; <span style=color:#a6e22e>max</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>max</span> = <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=45-跳跃游戏-iihttpsleetcodecnproblemsjump-game-ii><a href=https://leetcode.cn/problems/jump-game-ii/>45. 跳跃游戏 II</a><a hidden class=anchor aria-hidden=true href=#45-跳跃游戏-iihttpsleetcodecnproblemsjump-game-ii>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 那么我从0到7就只要2步，所以我们得保存2个覆盖范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>jump</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>max</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 最大的覆盖范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>premax</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 上一段的最大覆盖范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> { 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>val</span> &gt; <span style=color:#a6e22e>max</span> { 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>max</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>premax</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>premax</span> = <span style=color:#a6e22e>max</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=1005-k-次取反后最大化的数组和httpsleetcodecnproblemsmaximize-sum-of-array-after-k-negations><a href=https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/>1005. K 次取反后最大化的数组和</a><a hidden class=anchor aria-hidden=true href=#1005-k-次取反后最大化的数组和httpsleetcodecnproblemsmaximize-sum-of-array-after-k-negations>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>largestSumAfterKNegations</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>k</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>nums</span>) <span style=color:#75715e>// 先排序，从小到大，负数在前
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>] &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>k</span> &gt; <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 将前k个负数取反
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>*=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=134-加油站httpsleetcodecnproblemsgas-station><a href=https://leetcode.cn/problems/gas-station/>134. 加油站</a><a hidden class=anchor aria-hidden=true href=#134-加油站httpsleetcodecnproblemsgas-station>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>canCompleteCircuit</span>(<span style=color:#a6e22e>gas</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>cost</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 用于统计从某下标到当前位置的和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 用于表示总和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>gas</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cur</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>gas</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>cost</span>[<span style=color:#a6e22e>i</span>] 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>gas</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>cost</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span> &lt; <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>start</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sum</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 如果总和大于0，才可能走完
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=135-分发糖果httpsleetcodecnproblemscandy><a href=https://leetcode.cn/problems/candy/>135. 分发糖果</a><a hidden class=anchor aria-hidden=true href=#135-分发糖果httpsleetcodecnproblemscandy>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		所以可以先从一个方向，再从另一个方向
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>candy</span>(<span style=color:#a6e22e>ratings</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>ratings</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>ratings</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>candy</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>ratings</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>candy</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 先从左到右，如果比左边大就加一，否则等于1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>ratings</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ratings</span>[<span style=color:#a6e22e>i</span>] &gt; <span style=color:#a6e22e>ratings</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>ratings</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ratings</span>[<span style=color:#a6e22e>i</span>] &gt; <span style=color:#a6e22e>ratings</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> &gt; <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span>] {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>candy</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最后求和即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>candy</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=860-柠檬水找零httpsleetcodecnproblemslemonade-change><a href=https://leetcode.cn/problems/lemonade-change/>860. 柠檬水找零</a><a hidden class=anchor aria-hidden=true href=#860-柠檬水找零httpsleetcodecnproblemslemonade-change>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lemonadeChange</span>(<span style=color:#a6e22e>bills</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>money</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>} <span style=color:#75715e>// 分别表示5,10,20的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>bills</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span> { <span style=color:#75715e>// 当收到5时，直接收入即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>10</span> { <span style=color:#75715e>// 收到10时，找5元
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 如果没有5元，返回false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 如果是20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>1</span>] &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>] &gt; <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 先看有没有一张10块一张5块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>3</span> { <span style=color:#75715e>// 再看有没有3张5块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 都没有的话返回false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span> 
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>money</span>[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=406-根据身高重建队列httpsleetcodecnproblemsqueue-reconstruction-by-height><a href=https://leetcode.cn/problems/queue-reconstruction-by-height/>406. 根据身高重建队列</a><a hidden class=anchor aria-hidden=true href=#406-根据身高重建队列httpsleetcodecnproblemsqueue-reconstruction-by-height>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 		这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reconstructQueue</span>(<span style=color:#a6e22e>people</span> [][]<span style=color:#66d9ef>int</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 按身高从到小排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>people</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] &lt; <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] &gt; <span style=color:#a6e22e>people</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>0</span>] 
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> make([][]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 然后按照k来进行插入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>info</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>people</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>info</span>)
</span></span><span style=display:flex><span>        copy(<span style=color:#a6e22e>res</span>[<span style=color:#a6e22e>info</span>[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#a6e22e>res</span>[<span style=color:#a6e22e>info</span>[<span style=color:#ae81ff>1</span>]:])
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>[<span style=color:#a6e22e>info</span>[<span style=color:#ae81ff>1</span>]] = <span style=color:#a6e22e>info</span>
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=452-用最少数量的箭引爆气球httpsleetcodecnproblemsminimum-number-of-arrows-to-burst-balloons><a href=https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/>452. 用最少数量的箭引爆气球</a><a hidden class=anchor aria-hidden=true href=#452-用最少数量的箭引爆气球httpsleetcodecnproblemsminimum-number-of-arrows-to-burst-balloons>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 这个题也是一样，考虑按start排序还是按end排序
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 所以我们需要先确定一个维度，这里我按start排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findMinArrowShots</span>(<span style=color:#a6e22e>points</span> [][]<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 先按start从小到大排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>points</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] &lt; <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>points</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] &gt; <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] &lt; <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>points</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=435-无重叠区间httpsleetcodecnproblemsnon-overlapping-intervals><a href=https://leetcode.cn/problems/non-overlapping-intervals/>435. 无重叠区间</a><a hidden class=anchor aria-hidden=true href=#435-无重叠区间httpsleetcodecnproblemsnon-overlapping-intervals>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>eraseOverlapIntervals</span>(<span style=color:#a6e22e>intervals</span> [][]<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这里我按end排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>intervals</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] &lt; <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 所有start小于等于当前end的区间，都要合并
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>intervals</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] &lt; <span style=color:#a6e22e>end</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>end</span> = <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>intervals</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=763-划分字母区间httpsleetcodecnproblemspartition-labels><a href=https://leetcode.cn/problems/partition-labels/>763. 划分字母区间</a><a hidden class=anchor aria-hidden=true href=#763-划分字母区间httpsleetcodecnproblemspartition-labels>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>partitionLabels</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>26</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>,<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>end</span>[int(<span style=color:#a6e22e>c</span> <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>)] = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pre</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>,<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>end</span>[int(<span style=color:#a6e22e>c</span> <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>)] &gt; <span style=color:#a6e22e>cur</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>end</span>[int(<span style=color:#a6e22e>c</span> <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>)]
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>cur</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>cur</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>pre</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>cur</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=56-合并区间httpsleetcodecnproblemsmerge-intervals><a href=https://leetcode.cn/problems/merge-intervals/>56. 合并区间</a><a hidden class=anchor aria-hidden=true href=#56-合并区间httpsleetcodecnproblemsmerge-intervals>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>merge</span>(<span style=color:#a6e22e>intervals</span> [][]<span style=color:#66d9ef>int</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 按start排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Slice</span>(<span style=color:#a6e22e>intervals</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] &lt; <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>j</span>][<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>intervals</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新右边界
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>res</span>) &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>res</span>[len(<span style=color:#a6e22e>res</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>res</span>[len(<span style=color:#a6e22e>res</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] &lt; <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>res</span>[len(<span style=color:#a6e22e>res</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 加入结果集中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>intervals</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=738-单调递增的数字httpsleetcodecnproblemsmonotone-increasing-digits><a href=https://leetcode.cn/problems/monotone-increasing-digits/>738. 单调递增的数字</a><a hidden class=anchor aria-hidden=true href=#738-单调递增的数字httpsleetcodecnproblemsmonotone-increasing-digits>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>monotoneIncreasingDigits</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>%</span><span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>n</span> <span style=color:#f92672>/=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flag</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>nums</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>] &gt; <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] {    
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]<span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>flag</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可某个位置变为了9，那么后面位置都变为9，因为要取最大
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>flag</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=714-买卖股票的最佳时机含手续费httpsleetcodecnproblemsbest-time-to-buy-and-sell-stock-with-transaction-fee><a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/>714. 买卖股票的最佳时机含手续费</a><a hidden class=anchor aria-hidden=true href=#714-买卖股票的最佳时机含手续费httpsleetcodecnproblemsbest-time-to-buy-and-sell-stock-with-transaction-fee>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxProfit</span>(<span style=color:#a6e22e>prices</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>fee</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>prices</span>[<span style=color:#ae81ff>0</span>] <span style=color:#75715e>// 买入位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>prices</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>start</span> { <span style=color:#75715e>// 如果小于买入位置 则将该处设为买入位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>start</span> = <span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>fee</span> &gt; <span style=color:#a6e22e>start</span> { <span style=color:#75715e>// 如果该处减去手续费大于买入位置，则可以买入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>fee</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>start</span> = <span style=color:#a6e22e>p</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>fee</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=968-监控二叉树httpsleetcodecnproblemsbinary-tree-cameras><a href=https://leetcode.cn/problems/binary-tree-cameras/>968. 监控二叉树</a><a hidden class=anchor aria-hidden=true href=#968-监控二叉树httpsleetcodecnproblemsbinary-tree-cameras>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>minCameraCover</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果是叶子节点，则没有被覆盖
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果左右节点中有没有被覆盖到的，那就需要安装摄像头
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果左右节点中有安装摄像头，就不需要安装摄像头了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ol><li>贪心算法的主要就是要找到贪在哪里</li><li>对于一些简单题，我们很容易就可以想到贪在哪里</li><li>但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个</li><li>在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://oyzg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=https://oyzg.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://oyzg.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></li><li><a href=https://oyzg.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/>贪心算法</a></li></ul><nav class=paginav><a class=prev href=https://oyzg.github.io/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/><span class=title>« Prev Page</span><br><span>CS186笔记 RookieDB</span></a>
<a class=next href=https://oyzg.github.io/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/><span class=title>Next Page »</span><br><span>回溯算法</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法 on twitter" href="https://twitter.com/intent/tweet/?text=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95&url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f&hashtags=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%2c%e7%ae%97%e6%b3%95%2c%e9%9d%a2%e8%af%95%2c%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f&title=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95&summary=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95&source=https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f&title=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%20-%20https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法 on telegram" href="https://telegram.me/share/url?text=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95&url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E8%25B4%25AA%25E5%25BF%2583%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://oyzg.github.io/>My Favorite</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>