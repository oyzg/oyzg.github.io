[{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差不多\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差不多\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差不多\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"},{"content":"容器 容器的本质其实就是一个特殊的进程。它通过Linux NameSpace、Linux CGroups、rootfs来实现对进程的隔离和约束。\nDocker的核心步骤： 1、启用 Linux Namespace 配置； 2、设置指定的 Cgroups 参数； 3、切换进程的根目录（Change Root）。\nNameSpace NameSpace是用来修改进程视图的方法，通过NameSpace技术可以让这个进程只能看到自己这个namespace中的空间，使用方式则是通过添加相关参数。\nint pid = clone(main_function, stack_size, SIGCHLD, NULL); # 添加CLONE_NEWPID后容器内看到的pid就是1了，除此外还有Mount、UTS、IPC、Network 和 User等Namespace int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); CGroups 在NameSpace修改视图后，相比于虚拟化技术还是隔离得不够彻底，多个容器间使用的还是同一个操作系统内核，而且还有很多资源和对象不能NameSpace化，比如时间，在容器内修改时间是对宿主机可见的。\nCGroups（Linux Control Group）技术是用来对进程进行资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，从而防止一个进程把整个系统的资源吃光的情况。此外，还有对进程进行优先级设置、审计等作用。\n它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，通过修改该路径下的文件即可实现对进程的资源限制。\nrootfs 在对进程进行隔离后，容器内看到的文件系统应该是完全独立的，让其不受宿主机和其他容器的影响。Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知（对挂载点进行了隔离），即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样，只有在容器执行挂载后，才会看到与宿主机不同的文件系统。在Linux中有一个chroot命令可以改变进程的根目录到你指定的位置。\n但是我们一般需要在容器的根目录下挂载完整操作系统的文件系统，挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。\n需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所有容器都共享宿主机的操作系统内核。\nDocker在制作镜像时，引入了层的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。rootfs由三部分组成，如图所示。只读层包含操作系统的基础文件，可读写层包含你的程序、依赖包等，如果你删除了只读层的文件，就会在可读写层生成一个foo文件，Init层主要包含一些操作系统的配置信息，如/etc/hosts、/etc/resolv.conf，这些文件输入只读层，但是我们需要对这些配置文件进行修改，并且希望这些配置信息在docker commit时不包含在内。\nDocker Docker常用命令 数据拷贝：docker cp [源路径] [目标路径]，对于容器内的文件采用[容器名或容器ID]:[路径]的形式，如docker cp a.txt 062:/tmp 共享目录：通过-v参数挂载，docker run -v [宿主机路径]:[容器内路径] 网络模式 null：容器与宿主机之间不通信 host：容器与宿主机共享网络，docker run时使用\u0026ndash;net=host参数开启 bridge：容器与宿主机之间通过docker0网桥进行通信，使用\u0026ndash;net=bridge开启，一般不需要，因为是默认的 端口号映射需要bridge模式，在docker run 中指定-p参数，-p [宿主机端口]:[容器端口] Dockerfile 如前面rootfs部分所述，docker镜像是分成很多层的，可以用docker inspect [image name]来查看分层信息。\n如果需要自己构建镜像则可以通过docker build命令进行构建，-f参数指定Dockerfile文件，没有就是Dockerfile文件，需要目录下只有这一个Dockerfile文件\nDockerfile中的常用命令有：\nFROM:基础镜像 COPY:用于将本机的源码、配置文件等复制到镜像中，源文件必须在“构建上下文”路径中 RUN:用于执行SHELL命令，一行只能有一条命令，所以末尾用\\，命令之间使用\u0026amp;\u0026amp;相连，为了美观可以写一个sh文件，用COPY拷贝进来再RUN执行 变量:ARG和ENV，ARG变量只在镜像过程中可见，ENV变量在镜像构建和容器运行时均可见 TIP：Dockerfile每个指令都会生成一个镜像层，所以要精简\nKubernetes Kubernetes是一个容器编排工具。编排的意思就是能够按照用户意愿和系统规则，完全自动化的处理好容器之间的关系。调度是把容器按照某种规则，放在最佳节点上运行起来。\nKubunetes分为Master节点和note节点，Master节点由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。node节点最核心的部分是kubectl，用于和容器运行时打交道,此外还有kube-proxy用于管理容器的网络通信，ccontainer-runtime管理Pod的生命周期。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。\n除此之外，还有kubectl，是Kubernetes的命令行工具，用于和集群进行交互。\nminikube minikube 是一个迷你版的Kubernetes集群，常用命令：\nminikube version： 查看minikube版本 minikube start：启动minikube集群，\u0026ndash;kubernetes-version=指定版本 minikube stop：停止minikube集群 minikube status：查看minikube集群状态 minikube delete：删除minikube集群 minikube node list：查看minikube集群节点 kubectl kubectl是Kubernetes的命令行工具，用于和集群进行交互，常用命令：\nkubectl get pods|nodes|services|deployments|namespaces：查看所有pod｜node｜service｜deployment｜namespace信息 kubectl describe pods|nodes|services|deployments|namespaces：查看指定pod｜node｜service｜deployment｜namespace信息 kubectl create|delete|edit -f [文件名]：创建|删除|编辑 指定资源 kubectl apply -f [文件名]：使用文件创建资源 kubectl logs [pod名]：查看指定pod的日志 kubectl exec [pod名] [命令]：在指定pod中执行命令, kubectl exec [pod名] -it \u0026ndash;/bin/bash进入pod kubectl run [pod名] \u0026ndash;image=[镜像名]：运行一个pod kubectl get pod -n [namespace]：查看指定namespace下的所有pod kubectl api-resources：查看支持的所有API对象 kubectl explain [API对象]：查看API对象， \u0026ndash;dry-run=client -o yaml可以生成yaml样板 API对象 由于Kubenetes的设计思路——“单一职责”和“组合优于继承”，所有对象都尽量只关注自己的职责。 Pod Pod是Kubernetes的最小运行单位，一个Pod中可以运行多个容器，每个容器之间是相互隔离的，但是可以共享同一个IP地址和端口。yaml示例：\napiVersion: v1 kind: Pod metadata: name: busy-pod labels: owner: chrono env: demo region: north tier: back spec: containers: - image: busybox:latest name: busy imagePullPolicy: IfNotPresent env: - name: os value: \u0026#34;ubuntu\u0026#34; - name: debug value: \u0026#34;on\u0026#34; command: - /bin/echo args: - \u0026#34;$(os), $(debug)\u0026#34; resources: # 限制使用资源 requests: # 要申请的资源 cpu: 10m # 1000m = 1CPU时间 memory: 100Mi limits: # 使用资源的上限 cpu: 20m memory: 200Mi 由apiVersion、kind、metadata、spec四个基本组成部分，metadata包含pod的名称、标签、注解等信息，spec包含pod的运行参数，包括容器镜像、环境变量、命令、参数、端口映射、卷挂载、资源限制、调度策略等等。\nKubernetes 为检查应用状态定义了三种探针，它们分别对应容器不同的状态：\nStartup，启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。如果Startup探针失败，会尝试反复重启 Liveness，存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。如果容器异常也会重启容器 Readiness，就绪探针，用来检查应用是否已经准备好接收流量。如果失败会从Service负载均衡中移除，不再分配流量 应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态\n要使用探针需要预留“检查口”，如下，在ConfigMap中使用/ready作为检查口。\napiVersion: v1 kind: ConfigMap metadata: name: ngx-conf data: default.conf: | server { listen 80; location = /ready { return 200 \u0026#39;I am ready\u0026#39;; } } 探针的具体定义：\napiVersion: v1 kind: Pod metadata: name: ngx-pod-probe spec: volumes: - name: ngx-conf-vol configMap: name: ngx-conf containers: - image: nginx:alpine name: ngx ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d name: ngx-conf-vol startupProbe: # 启动探针 periodSeconds: 1 # 执行探测动作的时间间隔 # timeoutSeconds字段 探测动作的超时时间 # successThreshold字段 连续几次探测成功才认为是正常 # failureThreshold字段 连续几次探测失败才认为是异常 # 三种探测方式： exec、TCP Socket、HTTP GET exec: # 执行一个Linux命令 command: [\u0026#34;cat\u0026#34;, \u0026#34;/var/run/nginx.pid\u0026#34;] livenessProbe: # 存活探针 periodSeconds: 10 tcpSocket: # 使用 TCP 协议尝试连接容器的指定端口 port: 80 readinessProbe: # 就绪探针 periodSeconds: 5 httpGet: # 连接端口并发送 HTTP GET 请求 path: /ready port: 80 Job和CronJob 在线业务：长时间运行的，如nginx 离线业务：短时间运行的，如定时任务 Job和CronJob都是用来处理离线业务的，Job是处理临时任务，CronJob是处理定时任务。 Job的yaml示例： apiVersion: batch/v1 kind: Job metadata: name: echo-job spec: activeDeadlineSeconds: 15 backoffLimit: 2 completions: 4 parallelism: 2 template: spec: restartPolicy: OnFailure containers: - image: busybox name: echo-job imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] template定义了一个应用模版，里面用来嵌入Pod。 几个重要字段：\nactiveDeadlineSeconds，设置 Pod 运行的超时时间。 backoffLimit，设置 Pod 的失败重试次数。 completions，Job 完成需要运行多少个 Pod，默认是 1 个。 parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源 CronJob的yaml示例：\napiVersion: batch/v1 kind: CronJob metadata: name: echo-cj spec: # 这个spec是CronJob的配置 schedule: \u0026#39;*/* * * * *\u0026#39; # 定时，每分钟执行一次 jobTemplate: # 这个下面嵌套Job spec: template: # 这个下面嵌套Pod spec: restartPolicy: OnFailure containers: - image: busybox name: echo-cj imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/echo\u0026#34;] args: [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] ConfigMap和Secret ConfigMap和Secret用于保存配置信息，ConfigMap保存的是非敏感信息，如数据库连接信息，Secret保存的是敏感信息，如密码。这些信息都保存在etcd中。\nConfigMap的yaml示例：\napiVersion: v1 kind: ConfigMap metadata: name: info data: # 用来存储数据，kv结构 count: \u0026#39;10\u0026#39; debug: \u0026#39;on\u0026#39; path: \u0026#39;/etc/systemd\u0026#39; greeting: | say hello to kubernetes. Secret的yaml示例：\napiVersion: v1 kind: Secret metadata: name: user data: # 这些都是base64编码的， name: cm9vdA== # root pwd: MTIzNDU2 # 123456 db: bXlzY2Fw # mysql # 自己手动base64编码，-n是删除隐含的换行符 echo -n \u0026#34;123456\u0026#34; | base64 MTIzNDU2 使用方法： 1、环境变量的方式：利用pod.spec.containers.env.valueFrom以环境变量的形式注入Pod\napiVersion: v1 kind: Pod metadata: name: env-pod spec: containers: - env: - name: COUNT valueFrom: configMapKeyRef: #ConfigMap对象 name: info key: count - name: USERNAME valueFrom: secretKeyRef: #Secret对象 name: user key: name 2、Volume的方式：类似docker run -v，在Pod中挂载一个Volume，然后把Volume中的内容映射到容器中。\napiVersion: v1 kind: Pod metadata: name: vol-pod spec: # 定义两个 Volume，分别引用 ConfigMap 和 Secret，名字是 cm-vol 和 sec-vol volumes: - name: cm-vol configMap: name: info - name: sec-vol secret: secretName: user # 然后在容器中挂载 Volume containers: - volumeMounts: - mountPath: /tmp/cm-items name: cm-vol - mountPath: /tmp/sec-items name: sec-vol image: busybox name: busy imagePullPolicy: IfNotPresent command: [\u0026#34;/bin/sleep\u0026#34;, \u0026#34;300\u0026#34;] Deployment Deployment是用来部署应用程序的，用来处理在线业务，让应用永不宕机。\napiVersion: apps/v1 kind: Deployment metadata: labels: app: ngx-dep name: ngx-dep spec: replicas: 2 # 副本数，运行的Pod数量 selector: matchLabels: app: ngx-dep # 匹配标签，和下面的template中的标签一致 # 通过这种labels，解除了Deployment和Pod的强绑定，把组合关系变成了“弱引用” template: metadata: labels: app: ngx-dep spec: containers: - image: nginx:alpine name: nginx 通过scale命令来扩容： kubectl scale \u0026ndash;replicas=5 deploy ngx-dep\nDaemonset 用于在集群的每个节点上运行且仅运行一个Pod，主要用于日志收集、数据采集等场景。\napiVersion: apps/v1 kind: DaemonSet metadata: name: redis-ds labels: app: redis-ds spec: selector: matchLabels: name: redis-ds template: metadata: labels: name: redis-ds spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 污点（taint）和容忍度（toleration\nMaster默认不跑应用，需要配置taint和toleration来配置才能在master上运行pod。 方法一：去掉master节点的taint，末尾的-就是去除 kubectl taint node master node-role.kubernetes.io/master:NoSchedule-\n方法二：在创建节点的时候，添加toleration\ntolerations: - key: node-role.kubernetes.io/master effect: NoSchedule operator: Exists 静态Pod 默认在/etc/kubernetes/manifests下，Kubernetes 的 4 个核心组件 apiserver、etcd、scheduler、controller-manager都以静态 Pod 的形式存在的\nService 用于服务发现和负载均衡，通过iptables实现。\n生成yaml文件命令：kubectl expose deploy ngx-dep \u0026ndash;port=80 \u0026ndash;target-port=80 \u0026ndash;dry-run=client -o yaml\napiVersion: v1 kind: Service metadata: name: ngx-svc spec: selector: app: ngx-dep ports: - port: 80 # 外部端口 targetPort: 80 # 内部端口 protocol: TCP # 协议 type：ClusterIP # 还有“ExternalName”、“LoadBalancer”、\u0026#34;NodePort\u0026#34;，“NodePort”类型会创建一个专用映射端口，外部可访问 namespace\nkubectl get ns查看所有的namespace，默认情况下所有API对象都在defalult namespace下。\n基于 DNS 插件，可以以域名形式访问Service，Service对象的域名形式为：”对象. 名字空间.svc.cluster.local“，或者“对象. 名字空间”、“对象名”\nIngress Ingress是流量的总入口，统管集群的进出口数据，以及负载均衡（七层，Service是四层负载均衡）\nIngress Controller Ingress Controller是Ingress资源的实际执行者，负责监听Ingress资源的变化并根据规则配置负载均衡器。 常用的Ingress Controller实现有Nginx Ingress Controller。\n工作原理：\n用户创建Ingress资源定义路由规则 Ingress Controller持续监听API Server中的Ingress资源变化 当Ingress资源发生变化时，Controller更新其内部的负载均衡配置 外部流量通过Ingress Controller访问集群内的服务 IngreeClass 用于定义 Ingress 控制器的类型和配置，解决了集群中存在多个 Ingress 控制器时的路由冲突问题。\nPersistentVolume 用于管理存储资源，属于系统资源，与Node平级，Pod只拥有其使用权\nPersistentVolumeClaim，简称 PVC，用来向Kubernetes申请存储资源，由Pod使用，代表Pod向系统申请PV，申请成功后会将PV和PVC绑定（bind） StorageClass，在PV和PVC之间，帮助PVC找到合适的PV。 PV的yaml：\napiVersion: v1 kind: PersistentVolume metadata: name: host-10m-pv spec: storageClassName: host-test # 对应StorageClass # 访问模式，ReadWriteOnce（可读可写，只能被一个Pod使用）、ReadOnlyMany（只可读，可以被多个Pod使用）、ReadWriteMany（可读可写，可以被多个Pod使用） accessModes: - ReadWriteOnce capacity: # 存储容量 storage: 10Mi hostPath: # 存储卷的本地路径，在节点上创建的目录 path: /tmp/host-10m-pv/ PVC的yaml：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: host-5m-pvc spec: storageClassName: host-test accessModes: - ReadWriteOnce resources: requests: storage: 5Mi # 请求的存储容量 在Pod中使用PVC：\napiVersion: v1 kind: Pod metadata: name: host-pvc-pod spec: volumes: - name: host-pvc-vol persistentVolumeClaim: claimName: host-5m-pvc # 绑定PVC containers: - name: ngx-pvc-pod image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: host-pvc-vol mountPath: /tmp HostPath 是最简单的一种 PV，数据存储在节点本地，速度快但不能跟随 Pod 迁移\n要实现跨节点数据共享，需要使用NFS或者Ceph等网络存储系统\n# NFS PV apiVersion: v1 kind: PersistentVolume metadata: name: nfs-1g-pv spec: storageClassName: nfs accessModes: - ReadWriteMany capacity: storage: 1Gi nfs: path: /tmp/nfs/1g-pv # 需事先创建好 server: 192.168.10.208 以上PV都是静态存储卷，需要手动创建，而Provisioner可以自动管理、创建PV，是动态存储卷。Provisioner以Pod形式运行，部署Provisioner有三个yaml文件，rbac.yaml、class.yaml和deployment.yaml。\n使用Provisioner时就不需要定义PV了，只需要在PVC中指定StorageClass，StorageClass再关联到Provisioner。 StorageClass的yaml：\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # Provisioner名称 parameters: archiveOnDelete: \u0026#34;false\u0026#34; # \u0026#34;false\u0026#34;为自动回收存储空间 StatefulSet Deployment只能管理无状态的应用，StatefulSet管理有状态的，可以看作Deployment的特例。\nStatefulSet启动的Pod是有顺序的，名字为XXXX-0, XXXX-1等，可以根据编号来决定依赖关系，\nStatefulSet的yaml：\napiVersion: apps/v1 kind: StatefulSet metadata: name: redis-sts spec: serviceName: redis-svc # 和Service中metadata.name一致 volumeClaimTemplates: # PVC，为每个Pod自动创建PVC - metadata: name: redis-100m-pvc spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi replicas: 2 selector: matchLabels: app: redis-sts template: metadata: labels: app: redis-sts spec: containers: - image: redis:5-alpine name: redis ports: - containerPort: 6379 volumeMounts: - name: redis-100m-pvc mountPath: /data 写 Service 对象的时候要小心一些，metadata.name 必须和StatefulSet 里的 serviceName 相同，selector 里的标签也必须和 StatefulSet 里的一致。StatefulSet创建的Pod的域名和其他Pod不同，格式为“Pod名.服务名.名字空间.svc.cluster.local”，简写”Pod名.服务名“。\nnamespace namespace是Kubernetes中的一个概念，可以将集群切分成多个区域，同时namespace也是一种API对象，简称ns。Kubernetes中默认有四个namespace：default、kube-system、kube-public、kube-node-lease。要将API对象放入指定namespace中可以在metadata里添加一个namespace字段。\nResourceQuota 用于为namespace进行资源配额，yaml文件示例：\napiVersion: v1 kind: ResourceQuota metadata: name: dev-qt namespace: dev-ns spec: hard: # 硬性全局限制 requests.cpu: 10 # 10个CPU requests.memory: 10Gi limits.cpu: 10 limits.memory: 20Gi requests.storage: 100Gi persistentvolumeclaims: 100 pods: 100 configmaps: 100 secrets: 100 services: 10 count/jobs.batch: 1 count/cronjobs.batch: 1 count/deployments.apps: 1 在添加资源配额后，要求所有在里面运行的 Pod 都必须用字段 resources 声明资源需求，否则就无法创建。可以用LimitRange自动为Pod加上资源限制，LimitRange的yaml：\napiVersion: v1 kind: LimitRange metadata: name: dev-limits namespace: dev-ns spec: limits: - type: Container defaultRequest: cpu: 200m memory: 50Mi default: cpu: 500m memory: 100Mi - type: Pod max: cpu: 800m memory: 200Mi HorizontalPodAutoscaler 基于Metrics Server，它从 Metrics Server 获取当前应用的运行指标，主要是 CPU 使用率，再依据预定的策略增加或者减少 Pod 的数量 yaml:\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: ngx-hpa spec: maxReplicas: 10 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: ngx-hpa-dep targetCPUUtilizationPercentage: 5 在Deployment的spec下一定要写resources字段，否则无法实现自动扩缩容\nMetrics Server Metrics Server 是一个专门用来收集 Kubernetes 核心资源指标（metrics）的工具，它定时从所有节点的 kubelet 里采集信息,安装Metrics Server后可以使用kubectl top查看资源使用情况\nPrometheus 相对于Metrics Server，Prometheus的指标更全一些。Prometheus 是云原生监控领域的“事实标准”，用 PromQL 语言来查询数据，配合 Grafana可以展示直观的图形界面，方便监控。\nkubuadm——一键部署 使用方法：\n# 创建一个 Master 节点 $ kubeadm init # 将一个 Node 节点加入到当前集群中 $ kubeadm join \u0026lt;Master 节点的 IP 和端口 \u0026gt; Kubernetes在部署时，它的每一个组件都是一个需要被执行的、单独的二进制文件。所以部署十分麻烦，kubeadm的方案是把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。\n滚动更新 Kubernetes中rsion使用Pod模版的hash值来作为版本号。 要实现滚动更新，主要有以下几个命令：\nkubectl apply -f xxx.yaml,修改yaml文件后应用即可，Kubernetes会进行滚动更新（逐步的创建新版本Pod，删除旧版本Pod，最后只剩新版本Pod，旧版本Pod全部删除） kubectl rollout pause暂停更新 kubectl rollout resume恢复更新 kubectl rollout history查看版本历史，加上参数\u0026ndash;revision x，查看指定版本详细信息 kubectl rollout undo，回滚到上一个版本，\u0026ndash;to-revision参数指定版本 Deployment 的 metadata添加字段annotations类似label，但是label用于外部对象，annotations用于内部对象，其中kubernetes.io/change-cause是更新版本说明。 网络模型 Docker有三种网络模式：null、host 和 bridge，但是只适用于单机，Kubernetes提出了自己的网络模型IP-per-pod：\n集群里的每个 Pod 都会有唯一的一个 IP 地址。 Pod 里的所有容器共享这个 IP 地址。 集群里的所有 Pod 都属于同一个网段。 Pod直接可以基于IP地址访问另一个Pod，不需要做网络地址转换（NAT） CNI（Container Networking Interface） CNI 为网络插件定义了一系列通用接口，CNI插件大致分为三种：\nOverlay：它构建了一个工作在真实底层网络之上的“逻辑网络”，把原始的 Pod 网络数据封包，再通过下层网络发送出去，到了目的地再拆包。因为这个特点，它对底层网络的要求低，适应性强，缺点就是有额外的传输成本，性能较低。 Route：在底层网络之上工作，但它没有封包和拆包，而是使用系统内置的路由功能来实现Pod 跨主机通信。它的好处是性能高，不过对底层网络的依赖性比较强，如果底层不支持就没办法工作了 Underlay： 直接用底层网络来实现 CNI，也就是说 Pod 和宿主机都在一个网络里，Pod和宿主机是平等的。它对底层的硬件和网络的依赖性是最强的，因而不够灵活，但性能最高。 常用的CNI插件：\nFlannel：最早是Overlay模式，后来用 Host-Gateway 技术支持了 Route 模式，简单易用、但是性能不是很好 Calico：Route模式使用BGP 协议来维护路由信息，性能要比 Flannel 好，而且支持多种网络策略，具备数据加密、安全隔离、流量整形等功能 Cilium：同时支持 Overlay 模式和 Route 模式，它的特点是深度使用了 Linux eBPF 技术，在内核层次操作网络数据，所以性能很高，可以灵活实现各种功能 参考资料： 《Kubernetes入门实战课》— 罗剑锋（极客时间）\n","permalink":"http://localhost:1313/archives/kubernetes/","summary":"容器编排","title":"Kubernetes"},{"content":"之前看过《乔布斯传》，最近又看了一下雷军的《小米创业思考》。\n##小米创业史 雷军是程序员出身，通过对WPS进行反编译破解、加入新功能，被求伯君邀请加入金山，然后在金山呆了十多年，\n","permalink":"http://localhost:1313/archives/%E5%B0%8F%E7%B1%B3%E5%88%9B%E4%B8%9A%E6%80%9D%E8%80%83/","summary":"专注、极致、口碑、快","title":"《小米创业思考》"},{"content":"最近看了张宏杰的《曾国藩传》和周岭的《认知觉醒：开启自我改变的原动力》，读《认知觉醒》的过程中，很多能从曾国藩那儿学到的好习惯，在《认知觉醒》这本书中系统化地揭示了。\n比如曾国藩坚持写日记、读书，正和《认知觉醒》所说的每日反省、读书一样。\n《认知觉醒》 三重大脑 按照《认知觉醒》里面说的，大脑分为三个区域：本能脑、情绪脑、理智脑。本能脑和情绪脑占大多数，理智脑只有小部分，但正是理智脑最高级，能给予我们正确的指导，但是它太弱了，本能脑和情绪脑掌控着大脑，而本能脑和情绪脑又是倾向于低能耗、轻松、不用动脑的活动，所以导致了我们目光短浅、及时满足的天性。我们不用为我们有这种天性而烦恼，而是应该去学会如何控制他们，如果让本能脑和情绪脑为理智脑所控制。\n潜意识 理性可以理解为意识，感性可以理解为潜意识。我们不应该认为感性就是不好的，比如灵感，所以要学会去利用好两者，先用感性帮助自己选择，再用理性帮助自己思考。 我们很多时候会去回避痛苦，这可能会导致其转换为潜意识，所以在面对痛苦时，正确的做法是去正视它、解决它。\n元认知 元认知是一种更高维度的认知，是对自身思考过程的认知和理解。元认知就是自我反思+主动控制，跳出自身的思考，去思考我们的思考、我们的做法对还是不对，能不能做得更好，然后去控制自己\n专注力、学习力、行动力、情绪力 专注力：保持身心合一、专注当下 学习力：要在拉伸区练习，学会主动学习（输出而非输入），关联-\u0026gt;体系，好的学习策略应该是有反馈的，累了就休息，才能走的久 行动力：很多时候我们明明有想学习的东西，但是还没开始又在刷视频了，主要原因就是我们没有清晰的计划，所以行动力的关键在于清晰 情绪力：任何能造成压力的事情都会挤压我们的心智带宽，在这种情况下我们往往会做出不理智的决定，所以要保持冷静、保持理智 最简单的成长方法 早起 冥想 阅读 写作 跑步 ","permalink":"http://localhost:1313/archives/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/","summary":"不断反思，不断进步","title":"《认知觉醒》"},{"content":"课程地址：CS186\n缓存管理（Buffer Management） 我们在数据库中的读写操作都是在内存中的页（Page）上进行读写，缓存管理器则负责管理在内存中的页和处理来自文件和索引管理器的页请求。\n由于内存空间有限，我们不可能将所有页都保存在内存中，当内存满了而我们不存在我们需要的页时，我们就需要从磁盘中读取相应的页到内存中，同时将内存中的页写入磁盘中。\n在内存中，我们在缓存池（Buffer Pool）中，我们将空间划分为多个帧（Frame）来存放页，每一个帧中存放一个页。\n为了有效的管理缓存池中的帧，缓存管理器在内存中分配了额外的空间用来存放一张元数据表（Metadata table），表中包含四个字段：\nFrame ID：对应唯一的内存地址 Page ID：决定现在帧中包含的页 Dirty Bit：用来验证当前页是否被修改 Pin Count：用来记录当前页的请求者数量 处理请求 当请求的的页在内存中时，该帧的pin count加一，并且返回该页的内存地址 当请求的页不在但是buffer pool没有满时，找到这个页并读入内存，该页pin count设为1，并返回内存地址 当请求的页不在并且buffer pool没有空间时，就需要进行页面的置换 页面的置换策略很大程度上取决于页面访问模式，通过计算页面点击数来选择最佳策略。 Page hit就是请求的页在内存中，不需要读磁盘； Page miss就请求的页不在内存中，需要读磁盘，会有一个额外的IO消耗，所以好的置换策略是性能的关键因素。 Hit rate就是用Page hit数除以总的请求数。\n如果换出的页设置了dirty bit，需要写入磁盘来确保持久化，如果页在内存中有更新，dirty bit设置为1，写入磁盘后设置为0.\n当一个请求完成后会通知磁盘管理器减少该页的pin count。\nLRU（Least Recently Used-最近最少使用） 在LRU算法中，为了便于找到最近最少使用的页，我们需要在metadata table中加一列Last Used用来记录上一次使用的时间。\nLRU算法则是将pin count = 0 并且 last used最小的页换出，将需要的页换入。\n在具体计算中，我们可以按照如上方法进行计算，在数据量很少时，我们可以从当前插入的页往前，找到最久没有使用的页即可。\nMRU（Most Recently Used-最近最多使用） 在直觉上我们可能无法理解MRU算法，但是MRU的适用场景是这样的：比如我们在size=3的pool中循环查找（A、B、C、D），这种情况下，使用MRU的性能更佳，平均每size次只需置换一次。\n在MRU算法中则不需要添加额外的列，当需要置换时，我们只需将pin count = 0 并且最后换入的页换出即可\nClock Ploicy 在Clock Policy中，需要添加一列Ref bit来存储a Last Used value，并且Ref bit只需要1bit，而不是多个bit，它不同于LRU中的Last Used的地方在于最近使用的页为0，其他的页为1，因此节省的时间和空间。\n此外，Clock Policy还需要一个变量Clock Hand来记录考虑中的帧（这里为理解为下一次换出的页）\n在初始化时，所有ref bit为1，clock hand指向第一个unpinned（pin count = 0）的帧.\nClock Policy换出页面的程序如下：\n从0到最后循环遍历表中所有的帧，跳过pinned的帧，直到找到第一个unpinned且ref bit = 0的帧 如果当前遍历的帧 ref bit = 1，那么设置为0，并且将clock hand设置为下一个帧 找到后，移除这个页并且将ref bit设为1，将clock hand设为下一个帧 排序 不同与传统的排序算法，在数据库中对数据进行排序时，我们每次将页读入或者写出都是一次IO操作，因此我们对与时间复杂度的度量也不再是用O(),而是IO操作的次数。\nTwo Way External Merge Sort（二路归并算法） 为了有效的合并两个列表，我们需要保证两个列表都是有序的，而在最开始我们无法保证其是否有序，所以第一次阶段每一个列表都只有一个单独的页，我们称这个阶段为“conquer”。\n接着我们就可以开始进行合并排序，我们称合并的结果为“sorted runs”，一个“sorted runs”就是一个有序的页序列。\n直到我们只剩下一个“sorted runs”，排序才算是完成了。\n分析 在分析一个数据库算法时，最重要的指标就是这个算法消耗的IO次数。\n在二路归并算法中，我们假设有n个数据页，那么每次传递数据都需要2*n次IO，读写分别消耗一次IO。\n在整个排序的过程中，我们首先需要“conquer”，在这之后，我们需要log(n)次传递来进行合并，所以总共1+log(n)次传递，2n*(1+log(n))次IO操作。\n缓冲页（buffer page）或缓冲帧（buffer frame）是将页存储在内存中的一个槽。在合并的过程中，我们将两个页读入内存，分别占用一个buffer frame，在合并完成后，我们还需要一个buffer frame来存放合并完成的页，我们将合并前的buffer frame叫做“input buffer”，合并后的一个叫做“output buffer”。一旦这个页写满了，我们就需要将其写入磁盘，并开始构建新的页。在二路归并排序中，我们只需要3个buffer frame（两个input buffer， 一个output buffer）。\nFull External Sort（完全外部排序） 在二路归并排序中，我们的第一个阶段只对单个页进行排序，并且整个过程中，我们只用了3个buffer frame，而在实际情况中，buffer frame的个数不止3个，所以二路归并排序没有充分利用资源，并且传递次数更多。\n而完全外部排序能够充分利用buffer frame，假设有B个buffer frame，我们在“conquer”阶段，不是对单个页面进行排序了，而是对B个页进行排序，并得到一个“sorted runs”，在之后的合并阶段中，我们拿出一个buffer frame作为output buffer，剩下的B-1个作为input buffer。\n分析 假设我们需要对n个页进行排序，在“conquer”阶段，我们将n个页导入得到n/B个sorted runs，在后面的合并中，每一次传递都除以B-1，所以总共需要1+log_B-1(n/B)次传递，需要2n*(1+log_B-1(n/b))次IO操作。\n哈希 在数据库中，将类似的值分组在一起叫做hash。\n因为我们无法将所有的数据一次填入内存，所以我们需要构建多个不同的hash表并且将它们连接在一起。但这存在一个问题，如果同样的值存在两张hash表中，我们可以直接将两张hash表连接起来吗？ 答案当然是不可以，所以我们需要确保当一个值在内存中，其他相同的值也在内存中。\n在整个过程中，我们分为两个阶段，第一个阶段是“partitioning”（分片），第二个阶段是“conquer”。一个分片是用一个分片哈希函数得到值相同的集合。假设有B个buffer frame，在每次分片中，我们通过hash得到B-1个分片，也就是B-1个output buffer，因为有一个是作为input buffer。\n在完成分片后，适合内存（页数小于等于B）的分片就能进入hash表构建阶段，不适合的则递归地进行分片直到所有的分片最多只有B页，并且需要使用不同的hash函数。\n假设m为所需分片次数，r_i为第i次分片读入的页数，w_i为第i次分派你写出的页数，X为构建hash表的总页数，那么IO次数为m次分片所有的r_i和w_i的次数加上2X。\n此外hash还存在一些重要的属性：\nr_0 = N: 第一次分片需要读入所有的页 r_i \u0026lt;= w_i： 分片过程可能会创建额外的页 w_i \u0026gt;= r_(i+1)： 可能有的页进入构建阶段了，不需要再次分片 x \u0026gt;= N： 每次分片可能会增加页数 Joins (连接) 参考：知乎陈大炮笔记\n介绍 首先我们需要先了解join到底是什么，像“R INNER JOIN S ON R.name = S.name”的语句是如何执行的。完成一个Join是需要条件的，相当于把R和S两个关系根据匹配条件合并创建一个新关系，即，对于 R 中的每条记录 r_i 使用匹配条件找到 S 中的对应 s_j，并将\u0026rsquo;\u0026lt;r_i, s_j\u0026gt;\u0026lsquo;输出中作为新的行 (r的所有字段后面跟着s的所有字段)。\n在下面的连接算法中，我们不考虑将新关系写入磁盘的代价，因为我们假设join的新关系在稍后执行SQL查询涉及到的另一个操作符中会用到。\n常用两表连接算法 Simple Nested Loop Join 简单嵌套循环连接 简单嵌套循环连接是最简单的连接算法，假设我们有一个B页的缓存区，我们希望连接2个表，R和S，连接条件为θ，策略就是可以先获取 R 中的每条记录，然后再遍历 S 中的所有匹配项，最后产生对应匹配项。\n伪代码如下：\nfor each record ri in R: for each record sj in S: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; 这是一个糟糕的算法，我们从 R 中读取每条记录时，需要读取 S 中的每一页来寻找匹配。产生的I/O开销是 [R]+|R|[S] ，其中 [R] 是 R 中的页数， |R| 是 S 中的记录数。\nPage Nested Loop Join 页嵌套循环连接 相对于简单嵌套循环，页嵌套循环不是对R中每一条记录去读S的每一页，而是对R中的每一页读S中的每一页，从而减少了读取S中每一页的次数。\nfor each page pr in R: for each page ps in S: for each record ri in pr: for each record sj in ps: if θ(ri, sj): yield \u0026lt;ri, sj\u0026gt; 因此，页嵌套循环的IO开销为[R]+[R][S]。\nBlock Nested Loop Join 块嵌套循环连接 在页嵌套循环中，我们只用了3个缓存页（一个用于R，一个用于S，一个为输出缓冲区），我们想要读S的次数越少越好，所以，我们可以将B-2个缓存页用于R，这B-2个页称为Chunk，将Chunk中的每一条记录与S中的每一条记录相匹配，这样就可以进一步减少读S的次数。\n这里的关键思想是，我们想利用 缓冲区 来降低 I/O 开销，所以我们可以在缓冲区里尽可能多存储 R 的页，因为我们每个 Chunk 针对 S 中页都只读一次，所以更大的 Chunk 意味着更少的 I/O。然后用 R 的每个块与 S 的每条记录进行匹配。\nfor each block of B−2 pages Br in R: for each page ps in S: for each record ri in Br: for each record sj in ps: if θ(ri,sj): yield \u0026lt;ri, sj\u0026gt; IO开销为[R] + [R/(b-2)][S]\nIndex Nested Loop Join 索引嵌套循环连接 当S上有一个对应字段的索引时，它可以非常快的在S中查找r_i的匹配，其IO开销为[R + [R]*(在S中查找匹配记录的成本)，其中在S中查找匹配记录的成本因索引的类型而不同。\nfor each record ri in R: for each record sj in S where θ(ri,sj)==true: yield \u0026lt;ri, sj\u0026gt; Hash Join 哈希连接 如果R的记录小于等于B-2页，则我们可以在构建一个哈希表，如何读取S，在R的哈希表中查找匹配的记录。这称为\u0026rsquo;Naive Hash Join\u0026rsquo;朴素哈希连接，成本为[R]+[S]。它依赖于R能够装入内存，但这通常不太可能。此外我们需要把R构建成哈希表，这里成本也很高。\n为了解决这个问题，我们可以重复地将 R 和 S 哈希到 B-1 缓冲区中，这样我们就可以得到 ≤B−2 页大小的分区，使我们能够将它们放入内存中并执行朴素哈希连接。\n更具体地说，考虑每一对相关的分区 Ri 和 Si (即R的分区i和S的分区i)。如果 Ri 和 Si 都是大于 B-2 页，则将两个分区哈希成更小的分区。否则，如果 Ri 或 Si 小于等于 B-2 页，则停止分区并将较小的分区加载到内存中，以构建内存中的哈希表，并与其较大的分区执行朴素哈希连接。\n这个过程被称为 Grace Hash Join 优雅哈希连接，它的I/O代价是：子节点上哈希的代价加上朴素哈希连接的代价。哈希的代价可以根据我们需要重复哈希多少个分区的次数而改变。对分区 P 进行哈希的代价包括读取 P 中的所有页所需的 I/O 以及在对分区 P 进行哈希后写入所有结果分区所需的 I/O。\nGrace Hash Join 是很好，但它对键倾斜非常敏感，所以在使用这个算法时要小心。当许多记录具有相同的键时，就会发生键倾斜。例如，如果我们对一个列进行哈希，这个列的值只有 yes，虽然我们可以强行构建，但不管我们使用哪个哈希函数，它们最终都会在同一个桶中。\nSort-Merge Join 排序合并连接 // TODO\nAn Important Refinement 排序合并连接的一个重要改进 // TODO\n","permalink":"http://localhost:1313/archives/cs186%E7%AC%94%E8%AE%B0-rookiedb/","summary":"CS186学习笔记.","title":"CS186笔记 RookieDB"},{"content":"贪心算法 基础 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n所以要使用贪心算法，就得找出贪在哪里\n贪心算法没有套路，对于是否能用贪心，最好就是举反例，如果能举出来，则不能用\n贪心算法一般步骤：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 常见算法题 455. 分发饼干 // 小饼干喂小胃口，大饼干喂大胃口 // 先排序，然后按顺序找到满足胃口的最小饼干，可以从大到小，也可以从小到大 func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) i, j := 0, 0 count := 0 for i \u0026lt; len(g) \u0026amp;\u0026amp; j \u0026lt; len(s) { if s[j] \u0026gt;= g[i] { j++ i++ count++ } else { j++ } } return count } 376. 摆动序列 // 删除一些元素，使其成为摆动序列，那么要找到这样一个子序列，就要找到所有峰值 func wiggleMaxLength(nums []int) int { n := len(nums) if n == 1 || (n == 2 \u0026amp;\u0026amp; nums[0] != nums[1]) { return n } pre := 0 cur := 0 count := 1 for i := 0; i \u0026lt; n-1; i++ { cur = nums[i+1] - nums[i] if (cur \u0026gt; 0 \u0026amp;\u0026amp; pre \u0026lt;= 0) || (cur \u0026lt; 0 \u0026amp;\u0026amp; pre \u0026gt;= 0) { pre = cur count++ } } return count } 53. 最大子数组和\n// 如果前面加起来小于0，那我就不加前面的就可以了 func maxSubArray(nums []int) int { sum := 0 res := nums[0] for _, val := range nums { if sum \u0026lt; 0 { sum = 0 } sum += val if sum \u0026gt; res { res = sum } } return res } 122. 买卖股票的最佳时机 II // 可以随意买入卖出，但最多持有一张股票，那只要前一天的比后一天的小就买入，然后再卖出，反正不要手续费 func maxProfit(prices []int) int { profit := 0 n := len(prices) for i := 1; i \u0026lt; n; i++ { if prices[i] - prices[i-1] \u0026gt; 0 { profit += prices[i] - prices[i-1] } } return profit } 55. 跳跃游戏 // 这题不要到底想跳几步，也不是跳得越大越好，应该想成我的跳跃范围能不能覆盖终点 func canJump(nums []int) bool { max := 0 // 最大的覆盖范围 for i, val := range nums { if i \u0026gt; max { // 如果不能跳到这里了 return false } if i + val \u0026gt; max { max = i + val } } return true } 45. 跳跃游戏 II // 求最小步数，那么就是目前覆盖范围内的下一个最大覆盖范围，然后这里算一步 // 比如目前我位置是0，值为3，所以覆盖范围是3，然后我求出[1,3]中的最大覆盖范围，假如为7， // 那么我从0到7就只要2步，所以我们得保存2个覆盖范围 func jump(nums []int) int { max := 0 // 最大的覆盖范围 premax := 0 // 上一段的最大覆盖范围 n := len(nums) count := 0 for i, val := range nums { if i \u0026gt;= n-1 { return count } if i + val \u0026gt; max { max = i+val } if i == premax { count++ premax = max } } return -1 } 1005. K 次取反后最大化的数组和 // 贪心：将最大的负数取反，如果没有负数了，且k为奇数，则将最小的数取反 func largestSumAfterKNegations(nums []int, k int) int { n := len(nums) sum := 0 sort.Ints(nums) // 先排序，从小到大，负数在前 for i := 0; i \u0026lt; n; i++ { if nums[i] \u0026lt; 0 \u0026amp;\u0026amp; k \u0026gt; 0 { // 将前k个负数取反 nums[i] *= -1 k-- } sum += nums[i] } if k % 2 == 0 { return sum } sort.Ints(nums) return sum - 2*nums[0] } 134. 加油站 func canCompleteCircuit(gas []int, cost []int) int { cur := 0 // 用于统计从某下标到当前位置的和 sum := 0 // 用于表示总和 start := 0 for i := 0; i \u0026lt; len(gas); i++ { cur += gas[i] - cost[i] sum += gas[i] - cost[i] if cur \u0026lt; 0 { // 如果cur小于0了，说明从之前的坐标开始不能走完，所以从i+1开始走 start = i+1 cur = 0 } } if sum \u0026gt;= 0 { // 如果总和大于0，才可能走完 return start } return -1 } 135. 分发糖果 // 思路：这题容易纠结从左到右还是从右到左，但是其实不需要纠结，两个方向我们都需要考虑 //\t所以可以先从一个方向，再从另一个方向 func candy(ratings []int) int { if len(ratings) \u0026lt;= 1 { return len(ratings) } candy := make([]int, len(ratings)) candy[0] = 1 // 先从左到右，如果比左边大就加一，否则等于1 for i := 1; i \u0026lt; len(ratings); i++ { if ratings[i] \u0026gt; ratings[i-1] { candy[i] = candy[i-1] + 1 } else { candy[i] = 1 } } // 再从右到左，如果比右边大，则比较candy[i]和candy[i+1]+1,取大值 for i := len(ratings)-2; i \u0026gt;= 0; i-- { if ratings[i] \u0026gt; ratings[i+1] \u0026amp;\u0026amp; candy[i+1]+1 \u0026gt; candy[i] { candy[i] = candy[i+1] + 1 } } // 最后求和即可 sum := 0 for _, val := range candy { sum += val } return sum } 860. 柠檬水找零 func lemonadeChange(bills []int) bool { money := []int{0, 0, 0} // 分别表示5,10,20的数量 for _, val := range bills { if val == 5 { // 当收到5时，直接收入即可 money[0]++ } else if val == 10 { // 收到10时，找5元 if money[0] \u0026lt;= 0 { // 如果没有5元，返回false return false } money[0]-- money[1]++ } else { // 如果是20 if money[1] \u0026gt; 0 \u0026amp;\u0026amp; money[0] \u0026gt; 0 { // 先看有没有一张10块一张5块 money[0]-- money[1]-- } else if money[0] \u0026gt;= 3 { // 再看有没有3张5块 money[0] -= 3 } else { // 都没有的话返回false return false } money[2]++ } } return true } 406. 根据身高重建队列 // 思路：这题要用贪心算法的话，必须先排序，但是按哪个排序呢 // 这里有2个维度（h和k），我们需要先确定一个维度，再考虑另一维度，这里我先按身高从大到小排序 func reconstructQueue(people [][]int) [][]int { // 按身高从到小排序 sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] \u0026lt; people[j][1] } return people[i][0] \u0026gt; people[j][0] }) res := make([][]int, 0) // 然后按照k来进行插入 for _, info := range people { res = append(res, info) copy(res[info[1]+1:], res[info[1]:]) res[info[1]] = info } return res } 452. 用最少数量的箭引爆气球 // 这个题也是一样，考虑按start排序还是按end排序 // 所以我们需要先确定一个维度，这里我按start排序 func findMinArrowShots(points [][]int) int { // 先按start从小到大排序 sort.Slice(points, func(i, j int) bool { return points[i][0] \u0026lt; points[j][0] }) res := 1 // 然后对当前start最小的气球，找到start小于等于它的end的气球，这段区间中的气球可以一次射爆 for i, _ := range points { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i][0] \u0026gt; points[i-1][1] { res++ } else { if i \u0026gt; 0 \u0026amp;\u0026amp; points[i-1][1] \u0026lt; points[i][1] { points[i][1] = points[i-1][1] } } } return res } 435. 无重叠区间 // 这题也是一样，按start排序还是按end排序，其实都可以，只不过后序的遍历顺序不一样 func eraseOverlapIntervals(intervals [][]int) int { // 这里我按end排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][1] \u0026lt; intervals[j][1] }) end := intervals[0][1] count := 1 // 所有start小于等于当前end的区间，都要合并 for i := 1; i \u0026lt; len(intervals); i++ { if intervals[i][0] \u0026lt; end { continue } end = intervals[i][1] count++ } return len(intervals) - count } 763. 划分字母区间 // 这题比较简单，只需找到所有字母最后一次出现位置，然后遍历即可 func partitionLabels(s string) []int { end := make([]int, 26) for i,c := range s { end[int(c - \u0026#39;a\u0026#39;)] = i } cur := 0 pre := -1 res := []int{} for i,c := range s { if end[int(c - \u0026#39;a\u0026#39;)] \u0026gt; cur { cur = end[int(c - \u0026#39;a\u0026#39;)] } if i == cur { res = append(res, cur - pre) pre = cur cur = i+1 } } return res } 56. 合并区间 // 和删除重叠区间不同，我们需要实时更新边界，所以我们需要先确定一个边界 func merge(intervals [][]int) [][]int { res := [][]int{} // 按start排序 sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] \u0026lt; intervals[j][0] }) for i := 0; i \u0026lt; len(intervals); i++ { // 更新右边界 if len(res) \u0026gt; 0 \u0026amp;\u0026amp; res[len(res)-1][1] \u0026gt;= intervals[i][0] { if res[len(res)-1][1] \u0026lt; intervals[i][1] { res[len(res)-1][1] = intervals[i][1] } } else { // 加入结果集中 res = append(res, intervals[i]) } } return res } 738. 单调递增的数字 func monotoneIncreasingDigits(n int) int { nums := []int{} for n \u0026gt; 0 { nums = append(nums, n%10) n /= 10 } flag := -1 // 从后往前遍历（这里是因为前面把顺序反过来了），如果前面大于后面，在后面一位变为9，前面一位减一 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { nums[i]-- flag = i-1 } } // 可某个位置变为了9，那么后面位置都变为9，因为要取最大 for i := 0; i \u0026lt;= flag; i++ { nums[i] = 9 } res := 0 for i := len(nums)-1; i \u0026gt;= 0; i-- { res *= 10 res += nums[i] } return res } 714. 买卖股票的最佳时机含手续费 // func maxProfit(prices []int, fee int) int { start := prices[0] // 买入位置 sum := 0 for _, p := range prices { if p \u0026lt;= start { // 如果小于买入位置 则将该处设为买入位置 start = p } else { // 对于一个点我们有时候会纠结现在买还是最高点买，我们想最高点买，但是不确定什么时候是最高点，通过下面这样，我们每次只要有盈利就买入，并且将start设为当前价格减去手续费，就不用纠结是不是最高点了 if p - fee \u0026gt; start { // 如果该处减去手续费大于买入位置，则可以买入 sum += p - fee - start start = p - fee } } } return sum } 968. 监控二叉树 // 在这个题中，每个节点都可能又3种状态，0没有被覆盖，1有摄像头，2有被覆盖 // 然后因为我们需要从下面开始，才能最大程度的减少摄像头数量（叶子节点不装摄像头可以节省叶子节点数，从上往下的话只能节省根节点这一个），所以我们使用后序遍历，最后遍历中节点 func minCameraCover(root *TreeNode) int { var dfs func(root *TreeNode) int count := 0 dfs = func(root * TreeNode) int { if root == nil { return 2 } left := dfs(root.Left) right := dfs(root.Right) // 如果是叶子节点，则没有被覆盖 if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 0 } // 如果左右节点都被覆盖，则当前节点没有摄像头可以覆盖到 if left == 2 \u0026amp;\u0026amp; right == 2 { return 0 } // 如果左右节点中有没有被覆盖到的，那就需要安装摄像头 if left == 0 || right == 0 { count++ return 1 } // 如果左右节点中有安装摄像头，就不需要安装摄像头了 if left == 1 || right == 1 { return 2 } return -1 } if dfs(root) == 0 { count++ } return count } 总结 贪心算法的主要就是要找到贪在哪里 对于一些简单题，我们很容易就可以想到贪在哪里 但是对于中等或困难题则不简单，它可能有多个维度，这个时候我们需要逐个确定，慢慢来，先确定一个维度，再去想另一个 在确定维度时，可能先确定哪个维度都可以，但是它的遍历顺序则可能会不同 ","permalink":"http://localhost:1313/archives/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","summary":"贪心算法相关.","title":"贪心算法"},{"content":"回溯算法 基础 回溯算法也叫回溯搜索法，是一种搜索的方式\n回溯算法有时可以用于解决一些看起来比较复杂的问题，但是本质是穷举，所以效率还是会比较低\n回溯是从递归延伸出来的，只是在递归调用前后会做一些处理\n回溯一般可以解决以下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯其实可以理解成树形结构，它是一种限高的树\n回溯算法的框架：\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 常见算法题 组合问题 77. 组合 func combine(n int, k int) [][]int { res := [][]int{} path := []int{} var travel func(n, k, startIndex int) travel = func(n, k, startIndex int) { if k == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := startIndex; i \u0026lt;= n-k+1; i++ { path = append(path, i) // 处理节点 travel(n, k-1, i+1) // 递归 path = path[:len(path)-1] // 回溯 } } travel(n, k, 1) return res } 216. 组合总和 III func combinationSum3(k int, n int) [][]int { res := [][]int{} path := []int{} var travel func(k, n, start int) travel = func(k, n, start int) { if k == 0 { if n == 0 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } return } for i := start; i \u0026lt;= 9 - k + 1; i++ { path = append(path, i) travel(k-1, n-i, i+1) path = path[:len(path)-1] } } travel(k, n, 1) return res } 17. 电话号码的字母组合 func letterCombinations(digits string) []string { res := []string{} if len(digits) == 0 { return res } form := map[byte]string{\u0026#39;2\u0026#39;:\u0026#34;abc\u0026#34;, \u0026#39;3\u0026#39;:\u0026#34;def\u0026#34;, \u0026#39;4\u0026#39;:\u0026#34;ghi\u0026#34;, \u0026#39;5\u0026#39;:\u0026#34;jkl\u0026#34;, \u0026#39;6\u0026#39;:\u0026#34;mno\u0026#34;, \u0026#39;7\u0026#39;:\u0026#34;pqrs\u0026#34;, \u0026#39;8\u0026#39;:\u0026#34;tuv\u0026#34;,\u0026#39;9\u0026#39;:\u0026#34;wxyz\u0026#34;} combination := \u0026#34;\u0026#34; var travel func(digits string, start int) travel = func(digits string, start int) { if start == len(digits) { tmp := combination res = append(res, tmp) return } for _, v := range form[digits[start]] { combination += string(v) travel(digits, start+1) combination = combination[:len(combination)-1] } } travel(digits, 0) return res } 39. 组合总和 // 这题跟前面的题不同之处便在于可以无限次数的重复选取，所以要注意递归的地方start不要+1 func combinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i) //不要+1，同时可以防止取前面的数，造成重复的答案 combination = combination[:len(combination)-1] } } backtracking(candidates, target, 0) return res } 40. 组合总和 II // 思路：这题与上一题的区别在于集合可重复，但是结果不能重复，对应到树上就是同树层不重复，树枝可重复 // 所以结果需要去重，但是用map的话可能会超时，所以需要使用别的方法对树层去重 // 树层去重的话需要对数组排序，并且使用used数组记录同一树层中上一个数是否使用过 func combinationSum2(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } sort.Ints(candidates) used := make([]bool, len(candidates)) combination := []int{} var backtracking func(candidates []int, target, start int) backtracking = func(candidates []int, target, start int) { if target == 0 { tmp := make([]int, len(combination)) copy(tmp, combination) res = append(res, tmp) } if target \u0026lt; 0 { return } for i := start; i \u0026lt; len(candidates); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; candidates[i] == candidates[i-1] \u0026amp;\u0026amp; !used[i-1]{ continue // false说明上一个数在同一树层中未 } used[i] = true combination = append(combination, candidates[i]) backtracking(candidates, target - candidates[i], i+1) combination = combination[:len(combination)-1] used[i] = false } } backtracking(candidates, target, 0) return res } 分割问题(组合问题) 131. 分割回文串 // 思路和组合问题一样 func partition(s string) [][]string { res := [][]string{} path := []string{} var backtracking func(s string, start int) backtracking = func(s string, start int) { if start == len(s) { tmp := make([]string, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := start; i \u0026lt; len(s); i++ { if isPartition(s, start, i) { path = append(path, s[start:i+1]) backtracking(s, i+1) path = path[:len(path)-1] } } } backtracking(s, 0) return res } //判断是否为回文 func isPartition(s string,startIndex,end int)bool{ left:=startIndex right:=end for ;left\u0026lt;right;{ if s[left]!=s[right]{ return false } //移动左右指针 left++ right-- } return true } 93. 复原 IP 地址 func restoreIpAddresses(s string) []string { res := []string{} path := \u0026#34;\u0026#34; var backtracking func(s string, start, count int) backtracking = func(s string, start, count int) { if count == 4 { if start == len(s) { tmp := path res = append(res, tmp[:len(tmp)-1]) } return } for i := start; i \u0026lt; start+3 \u0026amp;\u0026amp; i \u0026lt; len(s); i++ { tmp := s[start:i+1] if !check(tmp) { return } path += tmp+\u0026#34;.\u0026#34; backtracking(s, i+1, count+1) path = path[:len(path)-i+start-2] } } backtracking(s, 0, 0) return res } func check(s string) bool { if s[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(s) \u0026gt; 1 { return false } num, _ := strconv.Atoi(s) if num \u0026gt; 255 { return false } return true } 子集问题 78. 子集 func subsets(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 90. 子集 II func subsetsWithDup(nums []int) [][]int { res := [][]int{} path := []int{} used := make([]bool, len(nums)) sort.Ints(nums) // 这种用到used数组的一定要先排序 var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if start \u0026gt; len(nums) { return } tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i \u0026lt; len(nums); i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1] { continue; } used[i] = true path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] used[i] = false } } backtracking(nums, 0) return res } 491. 递增子序列 func findSubsequences(nums []int) [][]int { res := [][]int{} path := []int{} var backtracking func(nums []int, start int) backtracking = func(nums []int, start int) { if len(path) \u0026gt;= 2 { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) } set := map[int]int{} // 因为是求子序列，不能排序，所以用map来去重（同树层去重） for i := start; i \u0026lt; len(nums); i++ { if _,ok := set[nums[i]]; ok || (len(path) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt; path[len(path)-1]) { continue } set[nums[i]]++ path = append(path, nums[i]) backtracking(nums, i+1) path = path[:len(path)-1] } } backtracking(nums, 0) return res } 排列问题 46. 全排列 func permute(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) used := make([]bool, n) // 使用used数组去重 var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { // 因为要取所有的排列，所以根据长度判断 tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res } 47. 全排列 II func permuteUnique(nums []int) [][]int { res := [][]int{} path := []int{} n := len(nums) sort.Ints(nums) used := make([]bool, n) var backtracking func(nums []int) backtracking = func(nums []int) { if len(path) == n { tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if used[i] || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) { continue } used[i] = true path = append(path, nums[i]) backtracking(nums) path = path[:len(path)-1] used[i] = false } } backtracking(nums) return res }\t332. 重新安排行程 func findItinerary(tickets [][]string) []string { targets := map[string]pairs{} for _, ticket := range tickets { if targets[ticket[0]] == nil { targets[ticket[0]] = make(pairs, 0) } targets[ticket[0]] = append(targets[ticket[0]], \u0026amp;pair{target: ticket[1], visited: false,}) } for _, target := range targets { sort.Sort(target) } res := []string{\u0026#34;JFK\u0026#34;} n := len(tickets) var backtracking func() bool backtracking = func() bool { if len(res) == n+1 { return true } m := targets[res[len(res)-1]] for _, pair := range(m) { if pair.visited { continue } res = append(res, pair.target) pair.visited = true if backtracking() { return true } pair.visited = false res = res[:len(res)-1] } return false } backtracking() return res } type pair struct { target string visited bool } type pairs []*pair func (p pairs) Len() int { return len(p) } func (p pairs) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p pairs) Less(i, j int) bool { return p[i].target \u0026lt; p[j].target } 51. N 皇后 func solveNQueens(n int) [][]string { res := [][]string{} path := [][]string{} for i := 0; i \u0026lt; n; i++ { s := []string{} for j := 0; j \u0026lt; n; j++ { s = append(s, \u0026#34;.\u0026#34;) } path = append(path, s) } var backtracking func(row int) backtracking = func(row int) { if row == n { tmp := make([]string, n) for i := 0; i \u0026lt; n; i++ { s := \u0026#34;\u0026#34; for j := 0; j \u0026lt; n; j++ { s += path[i][j] } tmp[i] = s } res = append(res, tmp) return } for i := 0; i \u0026lt; n; i++ { if !isValid(n, row, i, path) { continue } path[row][i] = \u0026#34;Q\u0026#34; backtracking(row+1) path[row][i] = \u0026#34;.\u0026#34; } } backtracking(0) return res } func isValid(n, row, col int, chessboard [][]string) bool { for i := 0; i \u0026lt; row; i++ { if chessboard[i][col] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col-1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i, j = i-1, j-1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } for i, j := row-1, col+1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i, j = i-1, j+1 { if chessboard[i][j] == \u0026#34;Q\u0026#34; { return false } } return true } 37. 解数独 func solveSudoku(board [][]byte) { var backtracking func(board [][]byte) bool backtracking = func(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { continue } for v := \u0026#39;1\u0026#39;; v \u0026lt;= \u0026#39;9\u0026#39;; v++ { if check(i, j, byte(v), board) { board[i][j] = byte(v) if backtracking(board) { return true } board[i][j] = \u0026#39;.\u0026#39; } } return false } } return true } backtracking(board) } func check(row, col int, val byte, board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { if board[i][col] == val { return false } } for i := 0; i \u0026lt; 9; i++ { if board[row][i] == val { return false } } a := row/3 b := col/3 for i := 0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if board[a*3+i][b*3+j] == val { return false } } } return true } 总结 回溯算法其实不难，但是它可以解决一些有点难度的题，从上面的题目中也可以看出来，基本上都是中等题，但是它效率不高，可以说是中等题困难题的入门算法吧\n回溯算法有一个模版，大多数回溯算法的题都可以在模版的基础上进行修改即可\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 对于一些简单的题，套用上面模版基本上就可以解决了，但是对于一些稍微困难一点点的题，它会加一些条件，比如集合中可以重复，集合中的元素可无限次选取等等\n集合可以重复的，而结果不能重复的情况：需要注意结果去重，这个去重指的是同一树层的去重 集合中元素可无限次选取（39.组合总和）：递归时start不需要+1 去重：去重可以分为同一树层去重和同一树枝去重\n同一树枝去重的话有两种方法： 排序+used数组：比如（40.组合总和II) set或者map去重：对于（491.递增子序列）这种不能排序的题则只能用set或map来去重了 一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果\n解题时注意一步一步慢慢来，像N皇后、解数独这种困难题，先把判断的方法写出来，剩下的其实和其他中等题差\n","permalink":"http://localhost:1313/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","summary":"回溯算法相关.","title":"回溯算法"},{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u0026gt; 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u0026lt; r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u0026gt;0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u0026lt; j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) sum := 0 for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) level := []int{} for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) max := queue[0].Val for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Val \u0026gt; max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) var pre *Node = nil for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) depth++ for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u0026gt; 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u0026gt; 0 { size := len(queue) for i := 0; i \u0026lt; size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34; if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \u0026#34;\u0026#34;) return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { if (length \u0026gt; maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u0026lt;= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026amp;TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u0026lt;= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u0026gt; maxNum { maxNum = v maxIndex = i } } return \u0026amp;TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } root := \u0026amp;TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026amp;TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u0026gt; maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026amp;\u0026amp; right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) { return root } if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u0026gt; val { if cur.Left == nil { cur.Left = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026amp;TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u0026gt; key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } else if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026amp;TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","permalink":"http://localhost:1313/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础 栈：先进后出 队列：先进先出 栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface { sort.Interface Push(x interface{}) // 将x添加至元素Len()的位置 Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface { Len() int // Len是集合中的元素个数。 Less(i, j int) bool Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct { s1 []int s2 []int } func Constructor() MyQueue { return MyQueue{ s1: make([]int, 0), s2: make([]int, 0), } } func (this *MyQueue) Push(x int) { this.s1 = append(this.s1, x) } func (this *MyQueue) Pop() int { for len(this.s1) \u0026gt; 0 { this.s2 = append(this.s2, this.s1[len(this.s1) - 1]) this.s1 = this.s1[:len(this.s1)-1] } res := this.s2[len(this.s2)-1] this.s2 = this.s2[:len(this.s2)-1] for len(this.s2) \u0026gt; 0 { this.s1 = append(this.s1, this.s2[len(this.s2)-1]) this.s2 = this.s2[:len(this.s2)-1] } return res } func (this *MyQueue) Peek() int { return this.s1[0] } func (this *MyQueue) Empty() bool { return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct { q1 []int q2 []int } func Constructor() MyStack { return MyStack{ q1: make([]int, 0), q2: make([]int, 0), } } func (this *MyStack) Push(x int) { this.q1 = append(this.q1, x) } func (this *MyStack) Pop() int { for len(this.q1) \u0026gt; 0 { this.q2 = append(this.q2, this.q1[0]) this.q1 = this.q1[1:] } res := this.q2[len(this.q2)-1] this.q2 = this.q2[:len(this.q2)-1] for len(this.q2) \u0026gt; 0 { this.q1 = append(this.q1, this.q2[0]) this.q2 = this.q2[1:] } return res } func (this *MyStack) Top() int { return this.q1[len(this.q1)-1] } func (this *MyStack) Empty() bool { return len(this.q1) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool { stack := make([]rune, 0) for _, v := range s { if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; { stack = append(stack, v) } else { if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) { stack = stack[:len(stack)-1] } else { stack = append(stack, v) } } } return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string { stack := make([]rune, 0) for _, v := range s { if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] { stack = stack[0:len(stack)-1] } else { stack = append(stack, v) } } var build strings.Builder for len(stack) != 0 { build.WriteString(string(stack[0])) stack = stack[1:] } return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, num1+num2) case \u0026#34;-\u0026#34;: stack = append(stack, num1-num2) case \u0026#34;*\u0026#34;: stack = append(stack, num1*num2) case \u0026#34;/\u0026#34;: stack = append(stack, num1/num2) } } } return stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int { queue := make([]int, 0) // 单调队列 for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列 for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减 queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) } res := []int{queue[0]} for i := k; i \u0026lt; len(nums); i++ { if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除 queue = queue[1:] } for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { queue = queue[:len(queue)-1] } queue = append(queue, nums[i]) res = append(res, queue[0]) } return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int { map_num := map[int]int{} for _, v := range nums { map_num[v]++ } h := \u0026amp;IHeap{} heap.Init(h) for key, value := range map_num { heap.Push(h, [2]int{key, value}) if h.Len() \u0026gt; k { heap.Pop(h) } } res := make([]int, k) for i := 0; i \u0026lt; k; i++ { res[k-i-1] = heap.Pop(h).([2]int)[0] } return res } type IHeap [][2]int func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i][1] \u0026lt; h[j][1] } func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IHeap) Pop() interface{} { old := *h res := old[len(old)-1] *h = old[:len(old)-1] return res } ","permalink":"http://localhost:1313/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"字符串 字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\n基础 Java 在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是不可变的\n创建字符串：\nString s = \u0026#34;java\u0026#34;;// 直接创建的字符串会存储在常量池中 String s = new String(\u0026#34;java\u0026#34;); // new出来的字符串在堆中 常用API：\nint n = s.length(); // 获取字符串长度 char c = s.charAt(i); // 获取第i个字符 boolean result = s1.equals(s2); //比较两个字符串的内容是否相同 int i = s.indexOf(c); // 获取某个字符在字符串中的第一个位置 boolean flag = s.IsEmpty(); // 判断字符串长度是否为0，为空报错 boolean flag = s.isblank(); // 判断字符串是否为空，为null返回true String s = s.replace(oldchar, newchar); // 用new代替old String[] ss = s.split(regex); // 分割字符串 String sub = s.subString(begin,[end]); // 获取子字符串 char[] cs = s.toCharArray(); // 转换为字符数组 String s = s.toLowerCase(); // 转为小写字符 String s = s.trim(); // 去除字符串前后的空格 String s = s.valueOf(object); // 将其他类型的对象转换为字符串 Go 常用操作：\nn := len(s) // 获取字符串长度 ss := strings.Split() // 分割字符串 res := strings.contains() // 判断是否包含 fmt.Sprintf() // 拼接字符串 i := strings.Index() // 获取某个字符在字符串中的第一个位置 c := s[i] // 获取下标为i的字符 KMP 主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n前缀表 是一个next数组，记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n// 构建next数组，记住next[i]代表s[:i]的最长公共前后缀的长度-1（-1是为了后面方便跳转） func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { // 如果si[i]和s[j+1]不相等了 j = next[j] // 就找前面已经匹配的最长公共前后缀 } if s[i] == s[j+1] { j++ } next[i] = j } } 常见算法题 344.反转字符串 力扣题目链接\nfunc reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 541. 反转字符串II 力扣题目链接\nfunc reverseStr(s string, k int) string { n := len(s) ss := []byte(s) for i := 0; i \u0026lt; n; i += 2*k { if i+k \u0026gt; n { reverseString(ss[i:]) } else { reverseString(ss[i:i+k]) } } return string(ss) } func reverseString(s []byte) { left := 0 right := len(s)-1 for left \u0026lt; right { s[left], s[right] = s[right], s[left] left++ right-- } } 题目：剑指Offer 05.替换空格 力扣题目链接\nfunc replaceSpace(s string) string { for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39; \u0026#39; { s = s[:i] + \u0026#34;%20\u0026#34; + s[i+1:] i += 2 } } return s } 151.翻转字符串里的单词 力扣题目链接\nfunc reverseWords(s string) string { //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) \u0026gt; 0 \u0026amp;\u0026amp; fastIndex \u0026lt; len(b) \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { fastIndex++ } //删除单词间冗余空格 for ; fastIndex \u0026lt; len(b); fastIndex++ { if fastIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[fastIndex-1] == b[fastIndex] \u0026amp;\u0026amp; b[fastIndex] == \u0026#39; \u0026#39; { continue } b[slowIndex] = b[fastIndex] slowIndex++ } //删除尾部冗余空格 if slowIndex-1 \u0026gt; 0 \u0026amp;\u0026amp; b[slowIndex-1] == \u0026#39; \u0026#39; { b = b[:slowIndex-1] } else { b = b[:slowIndex] } //2.反转整个字符串 reverse(\u0026amp;b, 0, len(b)-1) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i \u0026lt; len(b) { j := i for ; j \u0026lt; len(b) \u0026amp;\u0026amp; b[j] != \u0026#39; \u0026#39;; j++ { } reverse(\u0026amp;b, i, j-1) i = j i++ } return string(b) } func reverse(b *[]byte, left, right int) { for left \u0026lt; right { (*b)[left], (*b)[right] = (*b)[right], (*b)[left] left++ right-- } } 题目：剑指Offer58-II.左旋转字符串 力扣题目链接\n// 方法一：直接截取字符串再拼接 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } // 方法二：不申请额外空间 // 1.反转(0, n-1) // 2.反转(n, len(s)-1) // 3.反转整个字符串 func reverseLeftWords(s string, n int) string { b := []byte(s) reverse(b, 0, n-1) reverse(b,n, len(b)-1) reverse(b, 0, len(b)-1) return string(b) } func reverse(b []byte, left, right int){ for left \u0026lt; right{ b[left], b[right] = b[right],b[left] left++ right-- } } 28. 实现 strStr() 力扣题目链接\n// 暴力匹配 func strStr(haystack string, needle string) int { if len(haystack) == 0 { return 0 } n := len(haystack) m := len(needle) if n \u0026lt; m { return -1 } for i := 0; i \u0026lt; n-m+1; i++ { flag := true for j := 0; i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m; j++ { if haystack[i+j] != needle[j] { flag = false break } } if flag { return i } } return -1 } KMP算法：\n// KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) j := -1 for i := 0; i \u0026lt; len(haystack); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; haystack[i] != needle[j+1] { j = next[j] } if haystack[i] == needle[j+1] { j++ } if j == len(needle)-1 { return i - len(needle) + 1 } } return -1 } // 构建next数组 func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } 459.重复的子字符串 力扣题目链接\n// KMP算法 func repeatedSubstringPattern(s string) bool { len := len(s) if len == 0 { return false } next := make([]int, len) getNext(next, s) if next[len-1] != -1 \u0026amp;\u0026amp; len % (len - (next[len-1] + 1)) == 0 { return true } return false } func getNext(next []int, s string) { j := -1 next[0] = j for i := 1; i \u0026lt; len(next); i++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j+1] { j = next[j] } if s[i] == s[j+1] { j++ } next[i] = j } } ","permalink":"http://localhost:1313/archives/%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"\u003ch1 id=\"字符串\"\u003e字符串\u003c/h1\u003e\n\u003cp\u003e字符串在不同语言中的差异可能会比较大，所以要想熟练掌握字符串类的算法题，需要对自己所使用的的语言的字符串操作比较熟悉\u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"java\"\u003eJava\u003c/h3\u003e\n\u003cp\u003e在java中，String是一个类，不是基本数据类型之一，任何字符串都是一个对象，此外字符串在java中是\u003cstrong\u003e不可变\u003c/strong\u003e的\u003c/p\u003e\n\u003cp\u003e创建字符串：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e;\u003cspan style=\"color:#75715e\"\u003e// 直接创建的字符串会存储在常量池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e String(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;java\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// new出来的字符串在堆中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e常用API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003echarAt\u003c/span\u003e(i); \u003cspan style=\"color:#75715e\"\u003e// 获取第i个字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s1.\u003cspan style=\"color:#a6e22e\"\u003eequals\u003c/span\u003e(s2); \u003cspan style=\"color:#75715e\"\u003e//比较两个字符串的内容是否相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eindexOf\u003c/span\u003e(c); \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eIsEmpty\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串长度是否为0，为空报错\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eboolean\u003c/span\u003e flag \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003eisblank\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 判断字符串是否为空，为null返回true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003ereplace\u003c/span\u003e(oldchar, newchar); \u003cspan style=\"color:#75715e\"\u003e// 用new代替old\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e ss \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esplit\u003c/span\u003e(regex); \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString sub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003esubString\u003c/span\u003e(begin,\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eend\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e); \u003cspan style=\"color:#75715e\"\u003e// 获取子字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e[]\u003c/span\u003e cs \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoCharArray\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转换为字符数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etoLowerCase\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 转为小写字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003etrim\u003c/span\u003e(); \u003cspan style=\"color:#75715e\"\u003e// 去除字符串前后的空格\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eString s \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e s.\u003cspan style=\"color:#a6e22e\"\u003evalueOf\u003c/span\u003e(object); \u003cspan style=\"color:#75715e\"\u003e// 将其他类型的对象转换为字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"go\"\u003eGo\u003c/h3\u003e\n\u003cp\u003e常用操作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 获取字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ess\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSplit\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 分割字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eres\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003econtains\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 判断是否包含\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSprintf\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estrings\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eIndex\u003c/span\u003e() \u003cspan style=\"color:#75715e\"\u003e// 获取某个字符在字符串中的第一个位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e] \u003cspan style=\"color:#75715e\"\u003e// 获取下标为i的字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"kmp\"\u003eKMP\u003c/h2\u003e\n\u003cp\u003e主要思想：\u003cstrong\u003e当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了\u003c/strong\u003e\u003c/p\u003e","title":"字符串"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) Java：\n底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法 Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的 TreeMap 红黑树 有序 仅value能null iterator 不安全 / Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n暴力法（两层for循环） 哈希表 用数组代替哈希表 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := [26]int{} // m := make(map[rune]int) for _, v := range s { record[v-rune(\u0026#39;a\u0026#39;)]++ //m[v]++ } for _, v := range t { record[v-rune(\u0026#39;a\u0026#39;)]-- // m[v]--; // if m[v] \u0026lt; 0 { // return false // } } return record == [26]int{} // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int { m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } res := make([]int, 0) for _, v := range nums2 { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { res = append(res, v) m[v]-- } } return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool { m := make(map[int]int) m[n] = 1 for n != 1 { tmp := 0 for n \u0026gt; 0 { a := n%10 tmp += a*a n /= 10 } n = tmp if _, ok := m[n]; ok { return false } m[n] = 1 } return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if _, ok := m[target-v]; ok { return []int{i, m[target-v]} } m[v] = i } return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } res := 0 for _, v1 := range nums3 { for _, v2 := range nums4 { if _, ok := m[0-v1-v2]; ok { res += m[0-v1-v2] } } } return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _, v := range magazine { m[v]++ } for _, v:= range ransomNote { if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 { m[v]-- } else { return false } } return true } ","permalink":"http://localhost:1313/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础 链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型 单链表 双链表 循环链表 结构 // 单链表 class ListNode { int val; // 节点上存储的元素 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.next = null; } // 节点的构造函数 }; // 双链表 class ListNode { int val; // 节点上存储的元素 ListNode pre; // 指向上一个节点 ListNode next; // 指向下一个节点 ListNode(int x) { this.val = x; this.pre = null; this.next = null; } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) { ListNode cur = new ListNode(); ListNode res = cur; cur.next = head; while (cur != null \u0026amp;\u0026amp; cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return res.next; } func removeElements(head *ListNode, val int) *ListNode { pre := \u0026amp;ListNode{Next: head} for tmp := pre; tmp.Next != nil; { if tmp.Next.Val == val { tmp.Next = tmp.Next.Next } else { tmp = tmp.Next } } return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode { if head == nil { // 判断头结点是否为空 return head } cur := head.Next pre := head for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表 tmp := cur.Next // 记录cur.Next cur.Next = pre // 反转 pre = cur cur = tmp } head.Next = nil // 将原来的head（现在的tail）的Next设为nil return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ // 判空 return head } dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点 Val: -1, Next: head, } tmp := dummpHead for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{ pre := tmp.Next cur := pre.Next pre.Next = cur.Next //以下三步进行反转 tmp.Next = cur cur.Next = pre tmp = pre } return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode { end := head dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点 Val: -1, Next: head, } pre := dummpHead for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点 end = end.Next } for end != nil { // 将pre和end同时后移 end = end.Next pre = pre.Next } pre.Next = pre.Next.Next // 删除指定节点 return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { // 遍历链表A m[headA] = true headA = headA.Next } for headB != nil { // 遍历链表B if m[headB] { // 如果有公共节点，返回即可 return headB } m[headB] = true headB = headB.Next } return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA := headA curB := headB for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历 if curA == nil { curA = headB } else { curA = curA.Next } if curB == nil { curB = headA } else { curB = curB.Next } } if curA != nil { return curA } return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","permalink":"http://localhost:1313/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点 数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n) 各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\nJava：ArrayList C++：Vertor Go：slice（切片） 经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n左闭右闭即[left, right] 左闭右开即[left, right) 第一种：左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left \u0026lt;= right) { int mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target){ left = mid+1; } else { return mid; } } return -1; } } 第二种：左闭右开\nwhile (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid; } return -1; } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; //if (nums[mid] == target) { // right = mid; //} else if (nums[mid] \u0026lt; target) { // left = mid + 1; //} else if (nums[mid] \u0026gt; target) { // right = mid; // 注意 //} //因为要找目标数的左边界 对于相等的情况 也将right=mid //由于相对简洁，普通的二分查找也可以写成这种版本 if (nums[mid] \u0026gt;= target) { right = mid; } else { left = mid+1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } 左闭右闭：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + right + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return nums[right] == target ? right : -1; } } 练习题 双指针 双指针 排序 滑动窗口 模拟 小结 数组在内存中连续，读快写慢 常用解题方法： 二分查找 双指针法 滑动窗口 模拟行为 ","permalink":"http://localhost:1313/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念 时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界 常见时间复杂度 O(n) O(logn) O(n^2) O(nlogn) 计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; } 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; } return function3(x, n / 2) * function3(x, n / 2); } 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t * t * x; } return t * t; } 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n对于一分为一的递归，我们可以根据参数变化转换为循环 如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x) 对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析 空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结 递归算法 时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度 ","permalink":"http://localhost:1313/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"","permalink":"http://localhost:1313/archives/redis/","summary":"","title":"Redis"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n存储引擎相关命令\n查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ; MyISAM与InnoDB的区别\n锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索 事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现原理 MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障 并发事务带来的问题 丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致 隔离级别 读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题 索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\nHash存在Hash冲突问题 Hash不支持顺序查找和范围查找 与B树相比\nB+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定 与红黑树相比：\n有更低的层数，因此磁盘访问次数更少 索引类型 聚簇索引和非聚簇索引 聚簇索引：存储记录是物理上连续存在，物理存储按照索引排序，有利于范围查询，一张表中只能有一个聚簇索引。 非聚簇索引：非聚集索引是逻辑上的连续，物理存储并不连续，物理存储不按照索引排序。 覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点 选择合适的字段 不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的 频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引 日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"http://localhost:1313/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux Linux常用命令\n文件目录操作 ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容 文件查找 which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作 文件打包上传和下载 tar：压缩解压文件，-zcvf压缩，-zxvf解压 -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件 gzip：压缩文件，为.gz文件 文件权限 chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组 磁盘存储 df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间 性能监控和优化 top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程 网络命令 ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机 其他命令 grep：文本搜索工具 ps：显示当前进程的状态 ","permalink":"http://localhost:1313/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址 为什么要有虚拟内存？\n虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间 局部性原理\n时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 虚拟内存（虚拟存储器）的技术实现？\n请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理 请求分页与分页存储管理，两者有何不同呢？\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n内存碎片 外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费 内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢 内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n页表会非常大，使用多级页表解决 多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 段页式地址变换中要得到物理地址须经过三次内存访问：\n第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 页面置换算法 最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法 磁盘调度算法 先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法 进程管理 线程 运行中的程序叫线程\n进程的状态？\n创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态 在七状态模型中还有两种状态：\n阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行 进程创建的过程？\n为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列 进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息 PCB是如何组织的？\nPCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式 管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信 管道的通信方式效率低，不适合进程间频繁的交换数据 消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 P操作减一，V操作加一 信号：进程间通信机制唯一的异步通信机制 Socket 线程 线程是进程当中的一条执行流程\n线程的优缺点？\n优点：\n一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源； 缺点：\n当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃） 进程线程对比 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销； 调度算法 先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 ","permalink":"http://localhost:1313/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 七层网络模型 四层网络模型 应用层 传输层 网络层 网络接口层 应用层协议 HTTP（超文本传输协议） 首部字段 Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式 特点 优点：\n简单 灵活易于扩展 应用广泛，跨平台 缺点：\n无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改） 状态码 1xx:提示信息 2xx：成功 200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传） 3xx：重定向，301和302含字段Location表示跳转URL 301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件 4xx：客户端错误 400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源 5xx：服务端错误 500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙 Get与Post的区别 Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制 HTTP1.1 提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞 HTTP2 头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源 HTTP3 基于UDP协议实现了QUIC协议，有以下优点 无队头阻塞 更快地连接建立 连接迁移 HTTPS 与HTTP的区别 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书 如何解决HTTP安全问题 信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题 HTTPS通信过程 首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密 SSL/TLS握手 客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知 传输层协议 TCP 头部格式 ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接 三次握手 客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态 为什么是三次握手？\n保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费 四次挥手 客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接 TIME_WAIT状态为什么是2MSL？\n防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 协议 自动重传请求\n停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认 重传机制 超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传 超时重传时间RTO应略大于往返时延RTT 快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了 滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n接收窗口和发送窗口大小相等吗？\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n什么情况是发生了拥塞？\n只要发生了超时重传，就认为出现了拥塞\n拥塞控制四个算法？\n慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长 当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法 拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长 当触发了重传机制，就使用拥塞发生算法 拥塞发生 如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法 快速恢复 cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值 拥塞控制和流量控制的区别？\n流量控制是避免发送方的数据填满接收方的缓存 UDP 头部格式 TCP和UDP的区别？\n连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等 网络层协议 IP IP地址分类？\n无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析 域名解析流程\n首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端 ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应 NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\nPing的工作原理\n主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"http://localhost:1313/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"}]