[{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n   映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率     std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn)   std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n)   std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合       集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率     std::set 红黑树 有序 否 否 O(log n) O(log n)   std::multiset 红黑树 有序 是 否 O(logn) O(logn)   std::unordered_set 哈希表 无序 否 否 O(1) O(1)    Java：\n   底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code      Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法   Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的   TreeMap 红黑树 有序 仅value能null iterator 不安全 /    Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n 暴力法（两层for循环） 哈希表 用数组代替哈希表  func isAnagram(s string, t string) bool {  if len(s) != len(t) {  return false  }  record := [26]int{}  // m := make(map[rune]int)  for _, v := range s {  record[v-rune(\u0026#39;a\u0026#39;)]++  //m[v]++  }  for _, v := range t {  record[v-rune(\u0026#39;a\u0026#39;)]--  // m[v]--;  // if m[v] \u0026lt; 0 {  // return false  // }  }  return record == [26]int{}  // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int {  m := make(map[int]int)  for _, v := range nums1 {  m[v] = 1  }  res := make([]int, 0)  for _, v := range nums2 {  if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 {  res = append(res, v)  m[v]--  }  }  return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool {  m := make(map[int]int)  m[n] = 1  for n != 1 {  tmp := 0  for n \u0026gt; 0 {  a := n%10  tmp += a*a  n /= 10  }  n = tmp  if _, ok := m[n]; ok {  return false  }  m[n] = 1  }  return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int {  m := make(map[int]int)  for i, v := range nums {  if _, ok := m[target-v]; ok {  return []int{i, m[target-v]}  }  m[v] = i  }  return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {  m := make(map[int]int)  for _, v1 := range nums1 {  for _, v2 := range nums2 {  m[v1+v2]++  }  }  res := 0  for _, v1 := range nums3 {  for _, v2 := range nums4 {  if _, ok := m[0-v1-v2]; ok {  res += m[0-v1-v2]  }  }  }  return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool {  m := make(map[rune]int)  for _, v := range magazine {  m[v]++  }  for _, v:= range ransomNote {  if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 {  m[v]--  } else {  return false  }  }  return true } ","permalink":"https://oyzg.github.io/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础  链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型  单链表 双链表 循环链表    结构 // 单链表 class ListNode {  int val; // 节点上存储的元素  ListNode next; // 指向下一个节点  ListNode(int x) {  this.val = x;  this.next = null;  } // 节点的构造函数 };  // 双链表 class ListNode {  int val; // 节点上存储的元素  ListNode pre; // 指向上一个节点  ListNode next; // 指向下一个节点  ListNode(int x) {  this.val = x;  this.pre = null;  this.next = null;  } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) {  ListNode cur = new ListNode();  ListNode res = cur;  cur.next = head;  while (cur != null \u0026amp;\u0026amp; cur.next != null) {  if (cur.next.val == val) {  cur.next = cur.next.next;  } else {  cur = cur.next;  }  }  return res.next; } func removeElements(head *ListNode, val int) *ListNode {  pre := \u0026amp;ListNode{Next: head}  for tmp := pre; tmp.Next != nil; {  if tmp.Next.Val == val {  tmp.Next = tmp.Next.Next  } else {  tmp = tmp.Next  }  }  return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode {  if head == nil { // 判断头结点是否为空  return head  }  cur := head.Next  pre := head  for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表  tmp := cur.Next // 记录cur.Next  cur.Next = pre // 反转  pre = cur  cur = tmp  }  head.Next = nil // 将原来的head（现在的tail）的Next设为nil  return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode {  if head == nil || head.Next == nil{ // 判空  return head  }  dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点  Val: -1,  Next: head,  }  tmp := dummpHead  for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{  pre := tmp.Next  cur := pre.Next  pre.Next = cur.Next //以下三步进行反转  tmp.Next = cur  cur.Next = pre  tmp = pre  }  return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode {  end := head  dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点  Val: -1,  Next: head,  }  pre := dummpHead  for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点  end = end.Next  }  for end != nil { // 将pre和end同时后移  end = end.Next  pre = pre.Next  }  pre.Next = pre.Next.Next // 删除指定节点  return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode {  m := make(map[*ListNode]bool)  for headA != nil { // 遍历链表A  m[headA] = true  headA = headA.Next  }  for headB != nil { // 遍历链表B  if m[headB] { // 如果有公共节点，返回即可  return headB  }  m[headB] = true  headB = headB.Next  }  return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode {  curA := headA  curB := headB  for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历  if curA == nil {  curA = headB  } else {  curA = curA.Next  }  if curB == nil {  curB = headA  } else {  curB = curB.Next  }  }  if curA != nil {  return curA  }  return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode {  fast := head  slow := head  for fast != nil \u0026amp;\u0026amp; fast.Next != nil {  fast = fast.Next.Next  slow = slow.Next  if fast == slow {  for slow != head {  slow = slow.Next  head = head.Next  }  return head  }  }  return nil } ","permalink":"https://oyzg.github.io/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点  数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n)  各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\n Java：ArrayList C++：Vertor Go：slice（切片）  经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n 左闭右闭即[left, right] 左闭右开即[left, right)  第一种：左闭右闭\n while (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1  class Solution {  public int search(int[] nums, int target) {  int left = 0;  int right = nums.length-1;  while (left \u0026lt;= right) {  int mid = left + ((right - left) / 2);  if (nums[mid] \u0026gt; target) {  right = mid-1;  } else if (nums[mid] \u0026lt; target){  left = mid+1;  } else {  return mid;  }  }  return -1;  } } 第二种：左闭右开\n while (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]  class Solution {  public int search(int[] nums, int target) {  int left = 0, right = nums.length;  while (left \u0026lt; right) {  int mid = left + ((right - left) \u0026gt;\u0026gt; 1);  if (nums[mid] == target)  return mid;  else if (nums[mid] \u0026lt; target)  left = mid + 1;  else if (nums[mid] \u0026gt; target)  right = mid;  }  return -1;  } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) {  if (nums.length == 0) return -1;  int left = 0;  int right = nums.length; // 注意   while (left \u0026lt; right) { // 注意  int mid = (left + right) / 2;  //if (nums[mid] == target) {  // right = mid;  //} else if (nums[mid] \u0026lt; target) {  // left = mid + 1;  //} else if (nums[mid] \u0026gt; target) {  // right = mid; // 注意  //}  //因为要找目标数的左边界 对于相等的情况 也将right=mid  //由于相对简洁，普通的二分查找也可以写成这种版本  if (nums[mid] \u0026gt;= target) {  right = mid;  } else {  left = mid+1;  }  }  // 最后要检查 left 越界的情况  if (left \u0026gt;= nums.length || nums[left] != target)  return -1;  return left; } 左闭右闭：\nclass Solution {  public int search(int[] nums, int target) {  int n = nums.length;  int left = 0, right = n - 1;  while (left \u0026lt; right) {  int mid = left + right + 1 \u0026gt;\u0026gt; 1;  if (nums[mid] \u0026gt;= target) right = mid;  else left = mid + 1;  }  return nums[right] == target ? right : -1;  } } 练习题   双指针    双指针 排序    滑动窗口    模拟    小结  数组在内存中连续，读快写慢 常用解题方法：  二分查找 双指针法 滑动窗口 模拟行为    ","permalink":"https://oyzg.github.io/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念  时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界  常见时间复杂度  O(n) O(logn) O(n^2) O(nlogn)  计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) {\rif (n == 0) {\rreturn 1; // return 1 同样是因为0次方是等于1的\r}\rreturn function2(x, n - 1) * x;\r} 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) {\rif (n == 0) {\rreturn 1;\r}\rif (n % 2 == 1) {\rreturn function3(x, n / 2) * function3(x, n / 2)*x;\r}\rreturn function3(x, n / 2) * function3(x, n / 2);\r} 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) {\rif (n == 0) {\rreturn 1;\r}\rint t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来\rif (n % 2 == 1) {\rreturn t * t * x;\r}\rreturn t * t;\r} 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n 对于一分为一的递归，我们可以根据参数变化转换为循环  如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x)   对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析  空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结  递归算法  时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度    ","permalink":"https://oyzg.github.io/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n 存储引擎相关命令\n  查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ;   MyISAM与InnoDB的区别\n  锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索  事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID  原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  实现原理  MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障  并发事务带来的问题  丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致  隔离级别  读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题  索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\n Hash存在Hash冲突问题 Hash不支持顺序查找和范围查找  与B树相比\n B+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定  与红黑树相比：\n 有更低的层数，因此磁盘访问次数更少  索引类型 聚簇索引和非聚簇索引  聚簇索引：索引结构和数据存放在一起的索引 非聚簇索引：与聚簇索引相反，可能需要二次回表（覆盖索引不需要）  覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点  选择合适的字段  不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的   频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引  日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"https://oyzg.github.io/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux  Linux常用命令\n  文件目录操作  ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容   文件查找  which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作   文件打包上传和下载  tar：压缩解压文件，-zcvf压缩，-zxvf解压  -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件   gzip：压缩文件，为.gz文件   文件权限  chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组   磁盘存储  df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间   性能监控和优化  top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程   网络命令  ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机   其他命令  grep：文本搜索工具 ps：显示当前进程的状态    ","permalink":"https://oyzg.github.io/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n 程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址   为什么要有虚拟内存？\n  虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间   局部性原理\n  时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。   虚拟内存（虚拟存储器）的技术实现？\n  请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理   请求分页与分页存储管理，两者有何不同呢？\n 请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n 内存碎片  外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费   内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢  内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n 页表会非常大，使用多级页表解决  多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理  先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；  段页式地址变换中要得到物理地址须经过三次内存访问：\n 第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。  页面置换算法  最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法  磁盘调度算法  先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法  进程管理 线程 运行中的程序叫线程\n 进程的状态？\n  创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态  在七状态模型中还有两种状态：\n 阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行   进程创建的过程？\n  为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列  进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n 进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息   PCB是如何组织的？\n PCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式  管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信  管道的通信方式效率低，不适合进程间频繁的交换数据   消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据  P操作减一，V操作加一   信号：进程间通信机制唯一的异步通信机制 Socket  线程 线程是进程当中的一条执行流程\n 线程的优缺点？\n 优点：\n 一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源；  缺点：\n 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）  进程线程对比  进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销；  调度算法  先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法  ","permalink":"https://oyzg.github.io/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型  应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。  七层网络模型 四层网络模型  应用层 传输层 网络层 网络接口层  应用层协议 HTTP（超文本传输协议） 首部字段  Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式  特点 优点：\n 简单 灵活易于扩展 应用广泛，跨平台  缺点：\n 无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改）  状态码  1xx:提示信息 2xx：成功  200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传）   3xx：重定向，301和302含字段Location表示跳转URL  301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件   4xx：客户端错误  400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源   5xx：服务端错误  500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙    Get与Post的区别  Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制  HTTP1.1  提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞  HTTP2  头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源  HTTP3  基于UDP协议实现了QUIC协议，有以下优点  无队头阻塞 更快地连接建立 连接迁移    HTTPS 与HTTP的区别  在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书  如何解决HTTP安全问题  信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题  HTTPS通信过程  首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密  SSL/TLS握手  客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知  传输层协议 TCP 头部格式  ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接  三次握手  客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态   为什么是三次握手？\n  保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费  四次挥手  客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接   TIME_WAIT状态为什么是2MSL？\n 防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证  应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。  协议 自动重传请求\n 停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认  重传机制  超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传  超时重传时间RTO应略大于往返时延RTT   快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了  滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n 接收窗口和发送窗口大小相等吗？\n 并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n 什么情况是发生了拥塞？\n 只要发生了超时重传，就认为出现了拥塞\n 拥塞控制四个算法？\n  慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长  当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法   拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长  当触发了重传机制，就使用拥塞发生算法   拥塞发生  如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法   快速恢复  cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值     拥塞控制和流量控制的区别？\n  流量控制是避免发送方的数据填满接收方的缓存  UDP 头部格式  TCP和UDP的区别？\n  连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等  网络层协议 IP  IP地址分类？\n 无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析  域名解析流程\n  首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端  ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n 客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应  NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\n Ping的工作原理\n 主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"https://oyzg.github.io/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"}]