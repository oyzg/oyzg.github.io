[{"content":"二叉树 基础 先来看看定义：\n// Java public class TreeNode {  int val; // 值  TreeNode left; // 左节点  TreeNode right;// 右节点  TreeNode() {}  TreeNode(int val) { this.val = val; } } // Go type TreeNode struct {  Val int  Left *TreeNode  Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n 深度优先遍历（DFS）  前序遍历 中序遍历 后序遍历   广度优先遍历（BFS）  深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n 确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int {  res := []int{}  var preorder func(root *TreeNode)  preorder = func(root * TreeNode) {  if root == nil {  return  }  res = append(res, root.Val)  preorder(root.Left)  preorder(root.Right)  }  preorder(root)  return res }  // 中序遍历 func inorderTraversal(root *TreeNode) []int {  res := []int{}  var inorder func(root *TreeNode)  inorder = func(root * TreeNode) {  if root == nil {  return  }  inorder(root.Left)  res = append(res, root.Val)  inorder(root.Right)  }  inorder(root)  return res }  // 后序遍历 func postorderTraversal(root *TreeNode) []int {  res := []int{}  var postorder func(root *TreeNode)  postorder = func(root * TreeNode) {  if root == nil {  return  }  postorder(root.Left)  postorder(root.Right)  res = append(res, root.Val)  }  postorder(root)  return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  stack := []*TreeNode{root}  for len(stack) \u0026gt; 0 {  node := stack[len(stack)-1]  stack = stack[:len(stack)-1]  res = append(res, node.Val)  if node.Right != nil {  stack = append(stack, node.Right)  }  if node.Left != nil {  stack = append(stack, node.Left)  }  }  return res }  // 中序遍历 func inorderTraversal(root *TreeNode) []int {  res := []int{}  cur := root  stack := []*TreeNode{}  for cur != nil || len(stack) \u0026gt; 0 {  if cur != nil {  stack = append(stack, cur)  cur = cur.Left  } else {  cur = stack[len(stack)-1]  stack = stack[:len(stack)-1]  res = append(res, cur.Val)  cur = cur.Right  }  }  return res }  // 后序遍历 func postorderTraversal(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  stack := []*TreeNode{root}  for len(stack) \u0026gt; 0 {  node := stack[len(stack)-1]  stack = stack[:len(stack)-1]  res = append(res, node.Val)  if node.Left != nil {  stack = append(stack, node.Left)  }  if node.Right != nil {  stack = append(stack, node.Right)  }  }  reverse(res)  return res } func reverse(a []int) {  l, r := 0, len(a) - 1  for l \u0026lt; r {  a[l], a[r] = a[r], a[l]  l, r = l+1, r-1  } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { \tif root == nil { \treturn nil \t} \tvar stack = list.New()//栈  res:=[]int{}//结果集  stack.PushBack(root)  var node *TreeNode  for stack.Len()\u0026gt;0{  e := stack.Back()  stack.Remove(e)//弹出元素  if e.Value==nil{// 如果为空，则表明是需要处理中间节点  e=stack.Back()//弹出元素（即中间节点）  stack.Remove(e)//删除中间节点  node=e.Value.(*TreeNode)  res=append(res,node.Val)//将中间节点加入到结果集中  continue//继续弹出栈中下一个节点  }  node = e.Value.(*TreeNode)  //压栈顺序：右左中  if node.Right!=nil{  stack.PushBack(node.Right)  }  if node.Left!=nil{  stack.PushBack(node.Left)  }  stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符  stack.PushBack(nil)  }  return res  }  //中序遍历：左中右  //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int {  if root==nil{  return nil  }  stack:=list.New()//栈  res:=[]int{}//结果集  stack.PushBack(root)  var node *TreeNode  for stack.Len()\u0026gt;0{  e := stack.Back()  stack.Remove(e)  if e.Value==nil{// 如果为空，则表明是需要处理中间节点  e=stack.Back()//弹出元素（即中间节点）  stack.Remove(e)//删除中间节点  node=e.Value.(*TreeNode)  res=append(res,node.Val)//将中间节点加入到结果集中  continue//继续弹出栈中下一个节点  }  node = e.Value.(*TreeNode)  //压栈顺序：右中左  if node.Right!=nil{  stack.PushBack(node.Right)  }  stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符  stack.PushBack(nil)  if node.Left!=nil{  stack.PushBack(node.Left)  }  }  return res }  //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { \tif root == nil { \treturn nil \t} \tvar stack = list.New()//栈  res:=[]int{}//结果集  stack.PushBack(root)  var node *TreeNode  for stack.Len()\u0026gt;0{  e := stack.Back()  stack.Remove(e)  if e.Value==nil{// 如果为空，则表明是需要处理中间节点  e=stack.Back()//弹出元素（即中间节点）  stack.Remove(e)//删除中间节点  node=e.Value.(*TreeNode)  res=append(res,node.Val)//将中间节点加入到结果集中  continue//继续弹出栈中下一个节点  }  node = e.Value.(*TreeNode)  //压栈顺序：中右左  stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符  stack.PushBack(nil)  if node.Right!=nil{  stack.PushBack(node.Right)  }  if node.Left!=nil{  stack.PushBack(node.Left)  }  }  return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int {  res := [][]int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  level := []int{}  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, level)  }  return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int {  res := [][]int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  level := []int{}  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  level = append(level, node.Val)  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, level)  }  reverse(res)  return res }  func reverse(nums [][]int) {  i, j := 0, len(nums)-1  for i \u0026lt; j {  nums[i], nums[j] = nums[j], nums[i]  i++  j--  } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  if i == size-1 {  res = append(res, node.Val)  }  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 {  res := []float64{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  sum := 0  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  sum += node.Val  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, float64(sum)/float64(size))  }  return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int {  res := [][]int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  level := []int{}  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  level = append(level, node.Val)  for _,child := range node.Children {  if child != nil {  queue = append(queue, child)  }  }  }  res = append(res, level)  }  return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int {  res := []int{}  if root == nil {  return res  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  max := queue[0].Val  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  if node.Val \u0026gt; max {  max = node.Val  }  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  res = append(res, max)  }  return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node {  if root == nil {  return root  }  queue := []*Node{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  var pre *Node = nil  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  if pre != nil {  pre.Next = node  }  pre = node  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { \tif root == nil {  return root  }  queue := []*Node{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  var pre *Node = nil  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  if pre != nil {  pre.Next = node  }  pre = node  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int {  if root == nil {  return 0  }  depth := 0  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  depth++  }  return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int {  if root == nil {  return 0  }  depth := 0  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  depth++  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  if node.Left == nil \u0026amp;\u0026amp; node.Right == nil {  return depth  }  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode {  if root != nil {  root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)  }  return root }  // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode {  if root == nil {  return root  }  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  node.Left, node.Right = node.Right, node.Left  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool {  return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool {  if left == nil \u0026amp;\u0026amp; right == nil {  return true;  };  if left == nil || right == nil {  return false;  };  if left.Val != right.Val {  return false;  }  return defs(left.Left, right.Right) \u0026amp;\u0026amp; defs(right.Left, left.Right); }  // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool {  queue := []*TreeNode{root.Left, root.Right}  for len(queue) \u0026gt; 0 {  left := queue[0]  right := queue[1]  queue = queue[2:]  if left == nil \u0026amp;\u0026amp; right == nil {  continue  }  if left == nil || right == nil || left.Val != right.Val {  return false  }  queue = append(queue, left.Left, right.Right, left.Right, right.Left)  }  return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int {  if root == nil {  return 0  }  depth := 0  queue := []*Node{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  for _, child := range node.Children {  queue = append(queue, child)  }  }  depth++  }  return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int {  if root == nil {  return 0  }  count := 0  queue := []*TreeNode{root}  for len(queue) \u0026gt; 0 {  size := len(queue)  for i := 0; i \u0026lt; size; i++ {  node := queue[0]  queue = queue[1:]  count++  if node.Left != nil {  queue = append(queue, node.Left)  }  if node.Right != nil {  queue = append(queue, node.Right)  }  }  }  return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool {  return getHeight(root) != -1 }  func getHeight(root *TreeNode) int {  if root == nil {  return 0  }  left := getHeight(root.Left)  right := getHeight(root.Right)  if left == -1 || right == -1 || math.Abs(float64(left-right)) \u0026gt; 1 {  return -1  }  return int(math.Max(float64(left), float64(right))) + 1  } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string {  res := []string{}  var travel func(root *TreeNode, s string)  travel = func(root *TreeNode, s string) {  if root.Left == nil \u0026amp;\u0026amp; root.Right == nil {  res = append(res, s + strconv.Itoa(root.Val))  return  }  s += strconv.Itoa(root.Val) + \u0026#34;-\u0026gt;\u0026#34;  if root.Left != nil {  travel(root.Left, s)  }  if root.Right != nil {  travel(root.Right, s)  }  }  travel(root, \u0026#34;\u0026#34;)  return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool {  if p == nil \u0026amp;\u0026amp; q == nil {  return true  }  if p == nil || q == nil || p.Val != q.Val {  return false  }  return isSameTree(p.Left, q.Left) \u0026amp;\u0026amp; isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int {  if root == nil {  return 0  }  sum := 0  if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil {  sum += root.Left.Val  }  sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)  return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int {  maxLen := 1  maxValue := root.Val  var travel func(root *TreeNode, length int)  travel = func(root *TreeNode, length int) {  if root.Left == nil \u0026amp;\u0026amp; root.Right == nil {  if (length \u0026gt; maxLen) {  maxLen = length  maxValue = root.Val  return  }  }  if root.Left != nil {  travel(root.Left, length+1)  }  if root.Right != nil {  travel(root.Right, length+1)  }  }  travel(root, 1)  return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool {  if root == nil {  return false  }  if targetSum == root.Val \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil {  return true  }  return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int {  res := [][]int{}  var travel func(root *TreeNode, targetSum int, path []int)  travel = func(root *TreeNode, targetSum int, path []int) {  if root == nil {  return  }  path = append(path, root.Val)  if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == targetSum {  p := make([]int, len(path))  copy(p, path) // 注意此处，需要复制一个slice  res = append(res, p)  return  }  if root.Left != nil {  travel(root.Left, targetSum - root.Val, path)  }  if root.Right != nil {  travel(root.Right, targetSum - root.Val, path)  }  }  travel(root, targetSum, []int{})  return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode {  n := len(inorder)  if n \u0026lt;= 0 {  return nil  }  mid := postorder[n-1]  index := 0  for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标  if inorder[i] == mid {  index = i  break  }  }  root := \u0026amp;TreeNode {  Val: mid,  Left: buildTree(inorder[:index], postorder[:index]),  Right: buildTree(inorder[index+1:], postorder[index:n-1]),  }  return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode {  n := len(inorder)  if n \u0026lt;= 0 {  return nil  }  mid := preorder[0]  index := 0  for i := 0; i \u0026lt; n; i++ { // 找到root节点在inorder中的下标  if inorder[i] == mid {  index = i  break  }  }  root := \u0026amp;TreeNode {  Val: mid,  Left: buildTree(preorder[1:index+1], inorder[:index]),  Right: buildTree(preorder[index+1:], inorder[index+1:]),  }  return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode {  if len(nums) \u0026lt;= 0 {  return nil  }  maxNum := nums[0]  maxIndex := 0  for i, v := range nums {  if v \u0026gt; maxNum {  maxNum = v  maxIndex = i  }  }  return \u0026amp;TreeNode {  Val: maxNum,  Left: constructMaximumBinaryTree(nums[:maxIndex]),  Right: constructMaximumBinaryTree(nums[maxIndex+1:]),  } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {  if root1 == nil \u0026amp;\u0026amp; root2 == nil {  return nil  }  root := \u0026amp;TreeNode {}  if root1 == nil {  root = root2  } else if root2 == nil {  root = root1  } else {  root = \u0026amp;TreeNode {  Val: root1.Val+root2.Val,  Left: mergeTrees(root1.Left, root2.Left),  Right: mergeTrees(root1.Right, root2.Right),  }  }  return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode {  if root == nil {  return nil  }  if root.Val == val {  return root  }  node := searchBST(root.Left, val)  if node != nil {  return node  }  node = searchBST(root.Right, val)  return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool {  var verify func(root *TreeNode, min, max int64) bool  verify = func(root *TreeNode, min, max int64) bool {  if root == nil {  return true  }   if min \u0026gt;= int64(root.Val) || max \u0026lt;= int64(root.Val) {  return false  }  // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true  return verify(root.Right,int64(root.Val),max) \u0026amp;\u0026amp; verify(root.Left,min,int64(root.Val))  }  return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int {  var dfs func(node *TreeNode)  min := 100000  pre := -1  dfs = func(node *TreeNode) {  if node == nil {  return  }  dfs(node.Left)  if pre != -1 \u0026amp;\u0026amp; node.Val - pre \u0026lt; min {  min = node.Val - pre  }  pre = node.Val  dfs(node.Right)  }  dfs(root)  return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int {  var dfs func(node *TreeNode)  res := []int{}  maxCount := 0  count := 0  cur := 0  dfs = func(node *TreeNode) {  if node == nil {  return  }  dfs(node.Left)  if node.Val == cur {  count++  } else {  count = 1  }  cur = node.Val  if count \u0026gt; maxCount {  maxCount = count  res = []int{}  }  if count == maxCount {  res = append(res, cur)  }  dfs(node.Right)  }  dfs(root)  return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {  if root == nil {  return nil  }  if root == p || root == q {  return root  }  left := lowestCommonAncestor(root.Left, p, q)  right := lowestCommonAncestor(root.Right, p, q)  if left != nil \u0026amp;\u0026amp; right != nil {  return root  }  if left != nil {  return left  }  if right != nil {  return right  }  return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { \tif root == nil {  return nil  }  if root == q || root == p || (root.Val \u0026gt;= p.Val \u0026amp;\u0026amp; root.Val \u0026lt;= q.Val) || (root.Val \u0026lt;= p.Val \u0026amp;\u0026amp; root.Val \u0026gt;= q.Val) {  return root  }  if root.Val \u0026gt; p.Val \u0026amp;\u0026amp; root.Val \u0026gt; q.Val {  return lowestCommonAncestor(root.Left, p, q)  }  if root.Val \u0026lt; p.Val \u0026amp;\u0026amp; root.Val \u0026lt; q.Val {  return lowestCommonAncestor(root.Right, p, q)  }  return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode {  if root == nil {  return \u0026amp;TreeNode{  Val: val,  }  }  cur := root  for cur != nil {  if cur.Val \u0026gt; val {  if cur.Left == nil {  cur.Left = \u0026amp;TreeNode{  Val: val,  }  return root  }  cur = cur.Left  } else {  if cur.Right == nil {  cur.Right = \u0026amp;TreeNode{  Val: val,  }  return root  }  cur = cur.Right  }  }  return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode {  if root == nil {  return nil  }  if root.Val == key {  if root.Left == nil \u0026amp;\u0026amp; root.Right == nil {  return nil  } else if root.Right == nil {  return root.Left  } else if root.Left == nil {  return root.Right  } else {  cur := root.Right  for cur.Left != nil {  cur = cur.Left  }  cur.Left = root.Left  return root.Right  }  } else if root.Val \u0026gt; key {  root.Left = deleteNode(root.Left, key)  } else {  root.Right = deleteNode(root.Right, key)  }  return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode {  if root == nil {  return nil  } else if root.Val \u0026lt; low {  return trimBST(root.Right, low, high)  } else if root.Val \u0026gt; high {  return trimBST(root.Left, low, high)  } else {  root.Left = trimBST(root.Left, low, high)  root.Right = trimBST(root.Right, low, high)  }  return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode {  n := len(nums)  if n == 0 {  return nil  }  mid := n/2  root := \u0026amp;TreeNode {  Val: nums[mid],  Left: sortedArrayToBST(nums[:mid]),  Right: sortedArrayToBST(nums[mid+1:]),  }  return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode {  sum := 0  var dfs func(node *TreeNode)  dfs = func(node *TreeNode) {  if node == nil {  return  }  dfs(node.Right)  node.Val = sum + node.Val  sum = node.Val  dfs(node.Left)  }  dfs(root)  return root } ","permalink":"https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"二叉树相关.","title":"二叉树"},{"content":"栈和队列 基础  栈：先进后出 队列：先进先出  栈和队列在不同语言不同集合中的实现方式是不同的，有数组实现的，有链表实现的，但是最基本的就是以上两个特征。\n实现方式 Java 在Java中，Stack类继承自Vector类，Queue则是一个接口，最常见的实现方式是LinkedList，此外还有Dueue双端队列，Priority优先队列\nStack主要方法： 1. boolean empty() // 判断栈是否为空 2. E peek() // 返回栈顶对象，不移除 3. E pop()\t// 返回栈顶对象，并移除 4. E push(E item)\t// 压入栈顶 5. int search(Object o) //返回对象在栈的位置 Queue主要方法： 1. boolean add(E e)\t// 向队列中添加元素 2. E element()\t// 返回队列的头，且不移除 3. boolean offer(E e)\t// 向队列中添加元素 4. E peek()\t// 返回队列的头，且不移除 5. E poll()\t// 返回队列的头，且移除 6. E remove()\t// 返回队列的头，且移除 Go 在Golang中栈和队列最常用的实现方式是slice，对于优先队列（堆），在go中有一个heap接口，可以用于实现优先队列，要实现heap接口，只需定义一个type，实现一下方法即可，具体使用方法可参考347.前 K 个高频元素\ntype Interface interface {  sort.Interface  Push(x interface{}) // 将x添加至元素Len()的位置  Pop() interface{} // 移除并且返回元素Len()-1 } // 其中sort.Interface为 type Interface interface {  Len() int // Len是集合中的元素个数。  Less(i, j int) bool  Swap(i, j int) // Swap交换索引i和索引j的元素 } 常见算法题 232.用栈实现队列 力扣题目链接\ntype MyQueue struct {  s1 []int  s2 []int }   func Constructor() MyQueue {  return MyQueue{  s1: make([]int, 0),  s2: make([]int, 0),  } }   func (this *MyQueue) Push(x int) {  this.s1 = append(this.s1, x) }   func (this *MyQueue) Pop() int {  for len(this.s1) \u0026gt; 0 {  this.s2 = append(this.s2, this.s1[len(this.s1) - 1])  this.s1 = this.s1[:len(this.s1)-1]  }  res := this.s2[len(this.s2)-1]  this.s2 = this.s2[:len(this.s2)-1]  for len(this.s2) \u0026gt; 0 {  this.s1 = append(this.s1, this.s2[len(this.s2)-1])  this.s2 = this.s2[:len(this.s2)-1]  }  return res }   func (this *MyQueue) Peek() int {  return this.s1[0] }   func (this *MyQueue) Empty() bool {  return len(this.s1) == 0 \u0026amp;\u0026amp; len(this.s2) == 0 }   /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 力扣题目链接\ntype MyStack struct {  q1 []int  q2 []int }   func Constructor() MyStack {  return MyStack{  q1: make([]int, 0),  q2: make([]int, 0),  } }   func (this *MyStack) Push(x int) {  this.q1 = append(this.q1, x) }   func (this *MyStack) Pop() int {  for len(this.q1) \u0026gt; 0 {  this.q2 = append(this.q2, this.q1[0])  this.q1 = this.q1[1:]  }  res := this.q2[len(this.q2)-1]  this.q2 = this.q2[:len(this.q2)-1]  for len(this.q2) \u0026gt; 0 {  this.q1 = append(this.q1, this.q2[0])  this.q2 = this.q2[1:]  }  return res }   func (this *MyStack) Top() int {  return this.q1[len(this.q1)-1] }   func (this *MyStack) Empty() bool {  return len(this.q1) == 0 }   /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 20. 有效的括号 力扣题目链接\nfunc isValid(s string) bool {  stack := make([]rune, 0)  for _, v := range s {  if len(stack) == 0 || v == \u0026#39;(\u0026#39; || v == \u0026#39;[\u0026#39; || v == \u0026#39;{\u0026#39; {  stack = append(stack, v)  } else {  if (v == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;(\u0026#39;) || (v == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;[\u0026#39;) || (v == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; stack[len(stack)-1] == \u0026#39;{\u0026#39;) {  stack = stack[:len(stack)-1]  } else {  stack = append(stack, v)  }  }  }  return len(stack) == 0 } 1047. 删除字符串中的所有相邻重复项 力扣题目链接\nfunc removeDuplicates(s string) string {  stack := make([]rune, 0)  for _, v := range s {  if len(stack) != 0 \u0026amp;\u0026amp; v == stack[len(stack)-1] {  stack = stack[0:len(stack)-1]  } else {  stack = append(stack, v)  }  }  var build strings.Builder  for len(stack) != 0 {  build.WriteString(string(stack[0]))  stack = stack[1:]  }  return build.String() } 150. 逆波兰表达式求值 力扣题目链接\nfunc evalRPN(tokens []string) int { \tstack := []int{} \tfor _, token := range tokens { \tval, err := strconv.Atoi(token) \tif err == nil { \tstack = append(stack, val) \t} else { \tnum1, num2 := stack[len(stack)-2], stack[(len(stack))-1] \tstack = stack[:len(stack)-2] \tswitch token { \tcase \u0026#34;+\u0026#34;: \tstack = append(stack, num1+num2) \tcase \u0026#34;-\u0026#34;: \tstack = append(stack, num1-num2) \tcase \u0026#34;*\u0026#34;: \tstack = append(stack, num1*num2) \tcase \u0026#34;/\u0026#34;: \tstack = append(stack, num1/num2) \t} \t} \t} \treturn stack[0] } 239. 滑动窗口最大值 力扣题目链接\n// 基本思路： // 1.使用单调队列（递减），push时将小的移除再push func maxSlidingWindow(nums []int, k int) []int {  queue := make([]int, 0) // 单调队列  for i := 0; i \u0026lt; k; i++ { //先将前k个放入队列  for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] { // 如果queue最后一个比放入的值小，就把先把最后一个移除，之后再放入，这样来保持队列单调递减  queue = queue[:len(queue)-1]  }  queue = append(queue, nums[i])  }  res := []int{queue[0]}  for i := k; i \u0026lt; len(nums); i++ {  if len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[0] == nums[i-k] { // 如果queue第一个等于目前窗口第一个，则移除  queue = queue[1:]  }  for len(queue) \u0026gt; 0 \u0026amp;\u0026amp; queue[len(queue)-1] \u0026lt; nums[i] {  queue = queue[:len(queue)-1]  }  queue = append(queue, nums[i])  res = append(res, queue[0])  }  return res } 347.前 K 个高频元素 力扣题目链接\nfunc topKFrequent(nums []int, k int) []int {  map_num := map[int]int{}  for _, v := range nums {  map_num[v]++  }  h := \u0026amp;IHeap{}  heap.Init(h)  for key, value := range map_num {  heap.Push(h, [2]int{key, value})  if h.Len() \u0026gt; k {  heap.Pop(h)  }  }  res := make([]int, k)  for i := 0; i \u0026lt; k; i++ {  res[k-i-1] = heap.Pop(h).([2]int)[0]  }  return res }  type IHeap [][2]int  func (h IHeap) Len() int {  return len(h) }  func (h IHeap) Less(i, j int) bool {  return h[i][1] \u0026lt; h[j][1] }  func (h IHeap) Swap(i, j int) {  h[i], h[j] = h[j], h[i] }  func (h *IHeap) Push(x interface{}) {  *h = append(*h, x.([2]int)) }  func (h *IHeap) Pop() interface{} {  old := *h  res := old[len(old)-1]  *h = old[:len(old)-1]  return res } ","permalink":"https://oyzg.github.io/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"数组、二分查找、双指针相关.","title":"栈和队列"},{"content":"哈希表（散列表） 基础 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构\n通过哈希函数来将key和value映射起来\n哈希函数 将key转化成hashcode，然后对hash table的大小进行取模就可以得到key在hash table中的下标了\n既然是取模来得到下标，就可能会存在冲突的可能，这个就叫hash冲突（hash碰撞）\nHash碰撞 一般hash碰撞有两种方法：拉链法和线性探测法\n拉链法 拉链法即将哈希冲突的值存储在一个链表中\n但是如果链表过长， 就会影响哈希表的性能，所以哈希表需要选择合适的大小\n线性探测法 见名知义，即如果发生hash冲突，就从该点往后寻找空闲的位置\n各语言中常用哈希表\nC++：\n   映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率     std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn)   std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n)   std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)集合       集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率     std::set 红黑树 有序 否 否 O(log n) O(log n)   std::multiset 红黑树 有序 是 否 O(logn) O(logn)   std::unordered_set 哈希表 无序 否 否 O(1) O(1)    Java：\n   底层 有序否 键值对能否为Null 遍历 线程安全 哈希Code      Hashmap 数组+链表 无序 都可null iterator 不安全 内部hash方法   Hashtable 数组+链表 无序 都不可null Enumeration（iterator） 安全 Key自己的   TreeMap 红黑树 有序 仅value能null iterator 不安全 /    Go：\nMap\n常见算法题 哈希表相关的算法题会稍微简单一点，需要注意的点就是，因为哈希表是用空间换取了时间，所以哈希表的空间消耗会比较大，对于一些情况，比如key为26个字母，我们可以用数组来代替哈希表，key换成(int)key-‘a’即可\n242.有效的字母异位词 力扣题目链接\n方法：\n 暴力法（两层for循环） 哈希表 用数组代替哈希表  func isAnagram(s string, t string) bool {  if len(s) != len(t) {  return false  }  record := [26]int{}  // m := make(map[rune]int)  for _, v := range s {  record[v-rune(\u0026#39;a\u0026#39;)]++  //m[v]++  }  for _, v := range t {  record[v-rune(\u0026#39;a\u0026#39;)]--  // m[v]--;  // if m[v] \u0026lt; 0 {  // return false  // }  }  return record == [26]int{}  // return true } 349. 两个数组的交集 力扣题目链接\nfunc intersection(nums1 []int, nums2 []int) []int {  m := make(map[int]int)  for _, v := range nums1 {  m[v] = 1  }  res := make([]int, 0)  for _, v := range nums2 {  if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 {  res = append(res, v)  m[v]--  }  }  return res } 第202题. 快乐数 力扣题目链接\nfunc isHappy(n int) bool {  m := make(map[int]int)  m[n] = 1  for n != 1 {  tmp := 0  for n \u0026gt; 0 {  a := n%10  tmp += a*a  n /= 10  }  n = tmp  if _, ok := m[n]; ok {  return false  }  m[n] = 1  }  return true } 1. 两数之和 力扣题目链接\nfunc twoSum(nums []int, target int) []int {  m := make(map[int]int)  for i, v := range nums {  if _, ok := m[target-v]; ok {  return []int{i, m[target-v]}  }  m[v] = i  }  return nil } 第454题.四数相加II 力扣题目链接\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {  m := make(map[int]int)  for _, v1 := range nums1 {  for _, v2 := range nums2 {  m[v1+v2]++  }  }  res := 0  for _, v1 := range nums3 {  for _, v2 := range nums4 {  if _, ok := m[0-v1-v2]; ok {  res += m[0-v1-v2]  }  }  }  return res } 383. 赎金信 力扣题目链接\nfunc canConstruct(ransomNote string, magazine string) bool {  m := make(map[rune]int)  for _, v := range magazine {  m[v]++  }  for _, v:= range ransomNote {  if _, ok := m[v]; ok \u0026amp;\u0026amp; m[v] \u0026gt; 0 {  m[v]--  } else {  return false  }  }  return true } ","permalink":"https://oyzg.github.io/archives/%E5%93%88%E5%B8%8C%E8%A1%A8/","summary":"哈希表相关.","title":"哈希表"},{"content":"链表 基础  链表在内存上分散，通过指针的方式连接 链表读O(n),写O(1) 链表的类型  单链表 双链表 循环链表    结构 // 单链表 class ListNode {  int val; // 节点上存储的元素  ListNode next; // 指向下一个节点  ListNode(int x) {  this.val = x;  this.next = null;  } // 节点的构造函数 };  // 双链表 class ListNode {  int val; // 节点上存储的元素  ListNode pre; // 指向上一个节点  ListNode next; // 指向下一个节点  ListNode(int x) {  this.val = x;  this.pre = null;  this.next = null;  } // 节点的构造函数 }; 常考算法题 203.移除链表元素 基本思路：\n​\t因为链表题很多时候需要考虑头结点，所以很多情况都需要设置一个虚拟头节点pre(previous)\n​\t对链表进行遍历，对每一个pre.Next等于val的情况，将pre.Next删除，即使pre.Next指向pre.Next.Next\npublic ListNode removeElements(ListNode head, int val) {  ListNode cur = new ListNode();  ListNode res = cur;  cur.next = head;  while (cur != null \u0026amp;\u0026amp; cur.next != null) {  if (cur.next.val == val) {  cur.next = cur.next.next;  } else {  cur = cur.next;  }  }  return res.next; } func removeElements(head *ListNode, val int) *ListNode {  pre := \u0026amp;ListNode{Next: head}  for tmp := pre; tmp.Next != nil; {  if tmp.Next.Val == val {  tmp.Next = tmp.Next.Next  } else {  tmp = tmp.Next  }  }  return pre.Next } 707.设计链表 力扣题目链接\n单链表或双链表\n206.反转链表 力扣题目链接\n// 基本思路： // 设置两个变量pre和cur,每次将pre -\u0026gt; cur 变为 pre \u0026lt;- cur // 并提前设置一个临时变量tmp来表示原来的cur.Next // 反转之后，将pre设为cur，将cur设为tmp // 反转完成后需要将原来的head.Next设为nil，否则前2个节点会形成循环链表 func reverseList(head *ListNode) *ListNode {  if head == nil { // 判断头结点是否为空  return head  }  cur := head.Next  pre := head  for cur != nil \u0026amp;\u0026amp; pre != nil { // 遍历链表  tmp := cur.Next // 记录cur.Next  cur.Next = pre // 反转  pre = cur  cur = tmp  }  head.Next = nil // 将原来的head（现在的tail）的Next设为nil  return pre } 24. 两两交换链表中的节点 力扣题目链接\n// 基本思路： // 1.判断头结点是否为空 // 2.设置一个虚拟头结点dummpHead // 3.遍历链表，对每2个节点进行反转 // 3.1 设置两个节点pre，cur为需要进行反转的2个节点 // 3.2 将pre下一节点指向cur.Next // 3.3 tmp -\u0026gt; cur //\t3.4 pre \u0026lt;- cur // 4.最后返回虚拟头节点的下一节点即可 func swapPairs(head *ListNode) *ListNode {  if head == nil || head.Next == nil{ // 判空  return head  }  dummpHead := \u0026amp;ListNode{ // 设置虚拟头节点  Val: -1,  Next: head,  }  tmp := dummpHead  for tmp.Next != nil \u0026amp;\u0026amp; tmp.Next.Next != nil{  pre := tmp.Next  cur := pre.Next  pre.Next = cur.Next //以下三步进行反转  tmp.Next = cur  cur.Next = pre  tmp = pre  }  return dummpHead.Next } 19.删除链表的倒数第N个节点 力扣题目链接\n// 基本思路： // 1.因为可能删除的是头节点，所以设置一个虚拟头节点 // 2.找到第n个节点 // 3.两个指针(pre, end)同时往后移，直到end为空 // 4.此时pre为要删除节点的前一节点，将pre.Next指向下下节点即可 // 5.最后返回虚拟头节点的下一节点即可 func removeNthFromEnd(head *ListNode, n int) *ListNode {  end := head  dummpHead := \u0026amp;ListNode{ // 设置一个虚拟头节点  Val: -1,  Next: head,  }  pre := dummpHead  for i := 0; i \u0026lt; n \u0026amp;\u0026amp; end != nil; i++ { // 将end移至第n个节点  end = end.Next  }  for end != nil { // 将pre和end同时后移  end = end.Next  pre = pre.Next  }  pre.Next = pre.Next.Next // 删除指定节点  return dummpHead.Next } 面试题 02.07. 链表相交 力扣题目链接\n哈希表法：\n// 基本思路： // 1.思路很简单，用map来记录已经遍历过的节点 // 2.如果该节点存在于map中说明这个节点即为公共节点 // 3.先遍历一条链表再遍历另一条链表 // 4.如果没有公共节点，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode {  m := make(map[*ListNode]bool)  for headA != nil { // 遍历链表A  m[headA] = true  headA = headA.Next  }  for headB != nil { // 遍历链表B  if m[headB] { // 如果有公共节点，返回即可  return headB  }  m[headB] = true  headB = headB.Next  }  return nil // 如果没有返回nil即可 } 双指针法：\n// 基本思路： // 1.假设链表A长度为a，链表B长度为b，重合部分为c // 2.设置两个节点遍历两个链表，遍历完后遍历另一条链表 // 3.当遍历到a+b-c时，即遇到第一个重合节点，最后返回该节点即可 // 4.如果没有重合部分，那么最后都遍历了a+b，最后都为nil，返回nil即可 func getIntersectionNode(headA, headB *ListNode) *ListNode {  curA := headA  curB := headB  for curA != curB \u0026amp;\u0026amp; (curA != nil || curB != nil) { // 分别遍历  if curA == nil {  curA = headB  } else {  curA = curA.Next  }  if curB == nil {  curB = headA  } else {  curB = curB.Next  }  }  if curA != nil {  return curA  }  return nil } 142.环形链表II 力扣题目链接\n// 基本思路：（快慢指针） // 1.设置一个快指针，每次走2步，一个慢指针，每次走1步 // 2.判断有没有环： // 2.1 如果相遇即有环 // *为什么有环一定相遇？ // fast相对于slow每次多走一步，在进入环后一定会相遇 // 2.2 如果最后fast为nil，则没环 // 3.相遇后如何找到环入口： // 3.1 设起点到入口距离x，入口到相遇点距离y，相遇点到入口距离z（环的另一遍） // 3.2 slow走的距离为x+y，fast走的距离为x+y+n*(y+z)，fast走的距离是slow的2倍 // 3.3 所以2(x+y) = x+y+n*(y+z) ==\u0026gt; x+y = n*(y+z) ==\u0026gt; x = (n-1)(y+z) + z // 3.4 所以n \u0026gt;= 1 // 3.4.1 n为1时，fast走了一圈，化简得x = z //\t3.4.2 n \u0026gt; 1时，也是一样，只不过要多走n-1圈 // 3.5 所以只需slow和head同时移动，便会在入口相遇 func detectCycle(head *ListNode) *ListNode {  fast := head  slow := head  for fast != nil \u0026amp;\u0026amp; fast.Next != nil {  fast = fast.Next.Next  slow = slow.Next  if fast == slow {  for slow != head {  slow = slow.Next  head = head.Next  }  return head  }  }  return nil } ","permalink":"https://oyzg.github.io/archives/%E9%93%BE%E8%A1%A8/","summary":"链表相关算法,常考算法题.","title":"链表"},{"content":"数组 数组是最基础的一种数据结构，定义：数组是存放在连续内存空间上的相同类型数据的集合\n特点  数组在内存上是连续的 数组下标从0开始 数组支持随机访问，即在相同时间内访问任意元素 读操作和添加操作O(1)，插入删除操作O(n)  各语言版本 Type[] array;//定义 array = new Type[size];//初始化，必须指定长度 array = new Type[]{x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 Type array [size];//声明 Type array [] = {x1, x2, x3};//初始化 array[i]//读取或修改指定下标的值 var variable_name [SIZE] variable_type;//声明 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}//初始化 var salary float32 = balance[9]//访问元素 动态数组 在平时的使用中，数组的长度不可变造成了很多不方便，所以很多语言中有类似动态数组的数据结构存在\n Java：ArrayList C++：Vertor Go：slice（切片）  经典算法题 [二分查找]:https://leetcode-cn.com/problems/binary-search/ 二分查找有两种写法：\n 左闭右闭即[left, right] 左闭右开即[left, right)  第一种：左闭右闭\n while (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1  class Solution {  public int search(int[] nums, int target) {  int left = 0;  int right = nums.length-1;  while (left \u0026lt;= right) {  int mid = left + ((right - left) / 2);  if (nums[mid] \u0026gt; target) {  right = mid-1;  } else if (nums[mid] \u0026lt; target){  left = mid+1;  } else {  return mid;  }  }  return -1;  } } 第二种：左闭右开\n while (left \u0026lt; right)，这里使用 \u0026lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u0026gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]  class Solution {  public int search(int[] nums, int target) {  int left = 0, right = nums.length;  while (left \u0026lt; right) {  int mid = left + ((right - left) \u0026gt;\u0026gt; 1);  if (nums[mid] == target)  return mid;  else if (nums[mid] \u0026lt; target)  left = mid + 1;  else if (nums[mid] \u0026gt; target)  right = mid;  }  return -1;  } } 左右边界版本 左闭右开：\nint left_bound(int[] nums, int target) {  if (nums.length == 0) return -1;  int left = 0;  int right = nums.length; // 注意   while (left \u0026lt; right) { // 注意  int mid = (left + right) / 2;  //if (nums[mid] == target) {  // right = mid;  //} else if (nums[mid] \u0026lt; target) {  // left = mid + 1;  //} else if (nums[mid] \u0026gt; target) {  // right = mid; // 注意  //}  //因为要找目标数的左边界 对于相等的情况 也将right=mid  //由于相对简洁，普通的二分查找也可以写成这种版本  if (nums[mid] \u0026gt;= target) {  right = mid;  } else {  left = mid+1;  }  }  // 最后要检查 left 越界的情况  if (left \u0026gt;= nums.length || nums[left] != target)  return -1;  return left; } 左闭右闭：\nclass Solution {  public int search(int[] nums, int target) {  int n = nums.length;  int left = 0, right = n - 1;  while (left \u0026lt; right) {  int mid = left + right + 1 \u0026gt;\u0026gt; 1;  if (nums[mid] \u0026gt;= target) right = mid;  else left = mid + 1;  }  return nums[right] == target ? right : -1;  } } 练习题   双指针    双指针 排序    滑动窗口    模拟    小结  数组在内存中连续，读快写慢 常用解题方法：  二分查找 双指针法 滑动窗口 模拟行为    ","permalink":"https://oyzg.github.io/archives/%E6%95%B0%E7%BB%84/","summary":"数组、二分查找、双指针相关.","title":"数组"},{"content":"算法性能分析 时间复杂度 概念  时间复杂度：是一个与算法规模n相关的函数，用来描述算法的运行时间与规模之间的关系 大O：通常来讲，大O用来表示一般情况的时间复杂度，在《算法导论》中为上界  常见时间复杂度  O(n) O(logn) O(n^2) O(nlogn)  计算时间复杂度时，我们往往是忽略常数的，包括n前的常数，以及logn的底数\n递归的时间复杂度 递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归的时间复杂度\n示例1：\nint function2(int x, int n) {\rif (n == 0) {\rreturn 1; // return 1 同样是因为0次方是等于1的\r}\rreturn function2(x, n - 1) * x;\r} 在这个例子中，每次递归都是-1，很容易看出来复杂度为O(n)\n示例2：\nint function3(int x, int n) {\rif (n == 0) {\rreturn 1;\r}\rif (n % 2 == 1) {\rreturn function3(x, n / 2) * function3(x, n / 2)*x;\r}\rreturn function3(x, n / 2) * function3(x, n / 2);\r} 在这个例子中，节点数为2^3+2^2+2^1+2^0=15，根据推导可以得出=n-1，所以复杂度为O(n)\n示例3：\nint function4(int x, int n) {\rif (n == 0) {\rreturn 1;\r}\rint t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来\rif (n % 2 == 1) {\rreturn t * t * x;\r}\rreturn t * t;\r} 在该例子中，每次调用都是n/2，所以复杂度为O(logn)\n方法 分析递归算法的时间复杂度的关键点就在于每次递归时 参数的变化\n 对于一分为一的递归，我们可以根据参数变化转换为循环  如每次调用为f(n/2)，可以看成for(int i = x; i \u0026lt; l; i*=2) 如每次调用为f(n-x)，可以看成for(int i = x; i \u0026lt; l; i += x)   对于一分为多的递归，我们可以将递归想象成一个多叉树进行分析  空间复杂度 空间复杂度和时间复杂度大同小异\n在一些简单的算法中，看程序中定义了多少数组、map这些即可\n在递归算法中，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度\n总结  递归算法  时间复杂度：每次递归的时间复杂度 * 递归的次数 空间复杂度：每次递归的空间复杂度 * 递归深度    ","permalink":"https://oyzg.github.io/archives/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","summary":"算法时间复杂度、空间复杂度分析.","title":"算法性能分析"},{"content":"MySQL 存储引擎 MySQL 常用存储引擎为 MyISAM 和 InnoDB 两种 在 MySQL 5.5.5 版本开始默认存储引擎从 MyISAM 改为 InnoDB\n 存储引擎相关命令\n  查看提供的所有存储引擎：show engines 查看默认存储引擎：show variables like '%storage_engine%'; 查看表的存储引擎：show table status like \u0026quot;table_name\u0026quot; ;   MyISAM与InnoDB的区别\n  锁级别：MyISAM支持表级锁，不支持行级锁，InnoDB都支持 事务：MyISAM不支持事务，InnoDB支持事务，可提交和回滚 外键：MyISAM不支持外键，InnoDB支持外键 安全恢复：InnoDB可使用事务日志进行自动恢复，MyISAM不支持 性能：InnoDB具有更高的写入速度，处理大量数据性能更高，MyISAM读取速度更快 缓存和索引：InnoDB支持缓存数据和索引的大型缓冲区池，不支持全文搜索，MyISAM密钥缓冲区仅用于索引，支持全文搜索  事务 在逻辑上为一个整体的多个操作，即要么都执行，要么都不执行\n四大特性ACID  原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  实现原理  MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。 MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障  并发事务带来的问题  丢失修改：两个事务对同一个数据进行修改，后一个覆盖了前一个 脏读：读到另一个事务没有提交的数据 不可重复读：在一个事务中，对一组数据多次读取，得到的结果不一致 幻读：在一个事务中读取数据，读取的数据条数不一致  隔离级别  读未提交：允许读取其他事务未提交的数据，存在脏读、不可重复读、幻读问题 读已提交：只允许读其他事务已提交的数据，存在不可重复读、幻读问题 可重复读：对同一数据多次读取结果一致，存在幻读问题，InnoDB默认隔离级别 可串行化：所有事务逐个执行，可解决以上所有问题  索引 索引是一种用于快速查询和检索数据的数据结构\nMySQL索引使用的数据结构为B+树\nB+树的优点 与Hash表相比\n Hash存在Hash冲突问题 Hash不支持顺序查找和范围查找  与B树相比\n B+树的key和data都存放在叶子节点 B+树的叶子节点有一条引用链指向与它相邻的叶子节点 B+树的检索效率更稳定  与红黑树相比：\n 有更低的层数，因此磁盘访问次数更少  索引类型 聚簇索引和非聚簇索引  聚簇索引：索引结构和数据存放在一起的索引 非聚簇索引：与聚簇索引相反，可能需要二次回表（覆盖索引不需要）  覆盖索引 一个索引如果包含需要查询的字段，就是覆盖索引\n比如name字段有索引，select name from student where name = ‘xxxx’\n创建索引注意点  选择合适的字段  不为NULL的 频繁查询的 频繁需要排序的 频繁用于连接的 频繁作为条件查询的   频繁更新的需谨慎 尽可能建立联合索引 字符串字段使用前缀索引，占用空间更新 避免冗余索引  日志 redo log 是InnoDB所独有的，让MySQL拥有了崩溃恢复能力\nundo log bin log ","permalink":"https://oyzg.github.io/archives/mysql/","summary":"MySQL面试相关内容.","title":"MySQL"},{"content":"Linux  Linux常用命令\n  文件目录操作  ls：查看目录下的文件 cd：进入指定目录 pwd：查看当前目录 mkdir：创建目录 rm：删除文件或目录，-rf删除目录 rmdir：删除目录 mv：移动文件，或改名 cp：复制文件 touch：查看文件或目录的日期时间 cat：显示文件内容，-n显示行号 nl：输出文件内容自动加上行号 more：显示文件内容，与cat区别为按页显示 less：显示文件内容，与more区别为more仅能向前移动，不能向后移动，且less查看之前不会加载整个文件 head：显示文件开头 tail：显示指定文件末尾内容   文件查找  which：搜索某个系统命令位置 whereis：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate：快速的搜索系统内是否有指定的文件 find：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作   文件打包上传和下载  tar：压缩解压文件，-zcvf压缩，-zxvf解压  -z：支持gzip解压文件 -c：建立新的压缩文件 -x：从压缩文件中提取文件 -v：显示操作过程 -f：压缩指定文件   gzip：压缩文件，为.gz文件   文件权限  chmod：改变文件访问权限 chgrp：改变文件所属群组 chown：改变文件的所有者和群组   磁盘存储  df：显示指定磁盘文件的可用空间 du：显示每个文件和目录的磁盘使用空间   性能监控和优化  top：显示系统当前正在执行的进程的相关信息，包括进程id，内存使用率，cpu占用率等 free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存（swap）和内核缓存区内存 vmstat：用来显示虚拟内存信息 iostat：查看cpu、网卡、磁盘等设备的活动情况、负载信息 lsof：查看某个文件相关的进程   网络命令  ifconfig：查看配置网络 route：用于操作基于内核ip路由表 ping：确定主机与外部主机的状态 netstat：检验各端口网络连接情况 telnet：开启终端机阶段作业，并登入远端主机   其他命令  grep：文本搜索工具 ps：显示当前进程的状态    ","permalink":"https://oyzg.github.io/archives/linux/","summary":"Linux面试相关内容.","title":"Linux"},{"content":"操作系统理论知识 内存管理 内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。\n虚拟内存 操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来\n 程序中使用到的内存地址为虚拟内存地址 实际中硬件中的空间地址为物理内存地址   为什么要有虚拟内存？\n  虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间   局部性原理\n  时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。   虚拟内存（虚拟存储器）的技术实现？\n  请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。 请求段页式存储管理   请求分页与分页存储管理，两者有何不同呢？\n 请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。\n内存分段的不足之处：\n 内存碎片  外部碎片：产生了多个不连续的小物理内存，可用内存交换（Swap）解决 内部碎片：程序所有内存都被装载到了物理内存，但一部分内存可能不常用造成了浪费   内存交换效率低：内存交换造成的，因为Swap需要写入硬盘，硬盘访问速度慢  内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。\n不足：\n 页表会非常大，使用多级页表解决  多级页表 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表\n段页式内存管理  先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；  段页式地址变换中要得到物理地址须经过三次内存访问：\n 第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。  页面置换算法  最佳页面置换算法 先进先出置换算法 最近最久未使用的页面置换算法 时钟页面置换算法 最不常用页面置换算法  磁盘调度算法  先来先服务算法 最短寻道时间优先算法 扫描算法 循环扫描算法 LOOK与C-LOOK算法  进程管理 线程 运行中的程序叫线程\n 进程的状态？\n  创建态：正在被创建的状态 就绪态：可运行，但是其他进程在运行 运行态：占用CPU在运行 阻塞态：不满足可运行的条件，在等待某一事件发生 终止态：正在从系统中消失的状态  在七状态模型中还有两种状态：\n 阻塞挂起状态：进程在外存且等待某一事件发生 就绪挂起状态：进程在外存，只要进入内存就可以立刻运行   进程创建的过程？\n  为新进程分配分配唯一的进程标识符，申请一个PCB 为进程分配资源 初始化PCB 如果进程的调度队列能够接纳，就插入到就绪队列  进程控制块PCB PCB是进程的唯一标识，包含以下信息：\n 进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程状态、进程优先级 资源分配清单 CPU相关信息   PCB是如何组织的？\n PCB是通过链表的方式进行组织的，把具有相同状态的进程链接在一起，组成各种队列\n进程间通信方式  管道：输出数据是单向的，Linux中的| 命名管道FIFO：可在不相关的进程间进行相互通信  管道的通信方式效率低，不适合进程间频繁的交换数据   消息队列：保存在内核中的消息链表，不适合大数据的传输，存在用户态和内核态之间的数据拷贝开销 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中 信号量：一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据  P操作减一，V操作加一   信号：进程间通信机制唯一的异步通信机制 Socket  线程 线程是进程当中的一条执行流程\n 线程的优缺点？\n 优点：\n 一个进程可以同时存在多个进程 各个线程之间可以并发执行； 各个线程之间可以共享地址空间和文件等资源；  缺点：\n 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）  进程线程对比  进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销；  调度算法  先来先服务算法 最短作业优先调度算法 高响应比优先调度算法（响应比=（等待时间+服务时间）/服务时间） 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法  ","permalink":"https://oyzg.github.io/archives/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"操作系统面试相关内容.","title":"操作系统"},{"content":"计算机网络分层 目前主要使用的网络模型为五层网络模型\n五层网络模型  应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。运输层包括两种协议：TCP， UDP。 网络层 ：为主机提供通信服务，路由选择。网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议 数据链路层 ：为同一链路的主机提供数据传输服务。将分组封装成帧。协议包括：Ethernet，PPP，[CSMA/CD](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 链路层.md#csmacd-协议) 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。  七层网络模型 四层网络模型  应用层 传输层 网络层 网络接口层  应用层协议 HTTP（超文本传输协议） 首部字段  Host：请求的服务器域名 Content-Length：响应数据长度 Connection ：Keep-Alive为长连接 Content-Type：响应体数据格式 Content-Encoding：响应体数据压缩方式  特点 优点：\n 简单 灵活易于扩展 应用广泛，跨平台  缺点：\n 无状态双刃剑 明文传输双刃剑 不安全（明文可能被窃听，不验证身份可能被伪装，无法证明报文完整性可能被篡改）  状态码  1xx:提示信息 2xx：成功  200：OK，表示一切正常 204：No content，与200的区别在于响应头没有body数据 206：Partial Content，表示body为资源的一部分（应用于HTTP分块下载或断点续传）   3xx：重定向，301和302含字段Location表示跳转URL  301：永久重定向，请求资源已不存在 302：临时重定向，请求资源还存在 304：缓存重定向，资源未修改，重定向到已存在的缓存文件   4xx：客户端错误  400：请求报文错误，笼统的错误 403：服务器禁止访问资源 404：请求找不到资源   5xx：服务端错误  500：笼统的错误，并不知道发生了什么错误 501：客户端请求功能还不支持 502：服务器作为网关或代理，服务器自身正常，访问后端服务器发生了错误 503：服务器繁忙    Get与Post的区别  Get用于请求资源，Post用于对资源做修改处理 Get是幂等和安全的，Post不是幂等和安全的（幂等指多次执行结果相同） Get请求参数位于URL中，只支持ASCLL，长度有限制，Post请求数据在body中，无限制  HTTP1.1  提出了长连接的通信方式，减少了TCP重复连接断开所带来的开销，减轻了服务器端的负载 管道网络传输：不需要等待前一个请求响应再发送，减少了整体的响应时间 队头阻塞：服务器端仍然是按照顺序响应，如果发生阻塞，会导致所有请求阻塞  HTTP2  头部压缩：使用HPACK算法进行压缩 静态表编码 动态表编码 二进制帧 并发传输：多条stream复用一条TCP连接 服务器主动推送资源  HTTP3  基于UDP协议实现了QUIC协议，有以下优点  无队头阻塞 更快地连接建立 连接迁移    HTTPS 与HTTP的区别  在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，更加安全 在TCP三次握手基础上还需进行SSL/TLS 的握手 HTTP 的端口号是 80，HTTPS 的端口号是 443 HTTPS需向CA申请数字证书  如何解决HTTP安全问题  信息加密（混合加密）实现机密性，解决窃听问题 效验机制（摘要算法）实现完整性，解决篡改问题 数字证书解决冒充问题  HTTPS通信过程  首先是服务器将自己的公钥注册到CA，CA用自己的私钥对服务器的公钥签名并颁发数字证书 服务器将数字证书发送给浏览器（事先置入了CA的公钥），浏览器对数字证书进行解密得到服务器的公钥 浏览器用服务器的公钥对报文进行加密发送 服务器用自己的私钥对报文进行解密  SSL/TLS握手  客户端发送clientHello请求，包含版本，随机数（用于生产会话密钥），密码套件列表等信息 服务端响应serverHello，包含确认的版本和密码套件列表，随机数（用户生产会话密钥），数字证书 客户端回应一个加密的随机数，加密通信算法改变通知和客户端握手结束通知 服务端通过加密算法得出会话密钥，最后回应加密通信算法改变通知和服务端握手结束通知  传输层协议 TCP 头部格式  ACK：为1表示确认应答报文 RST：为1表示出现异常时必须断开连接 SYN：为1表示希望建立连接 FIN： 为1表示希望断开连接  三次握手  客户端发送一个SYN为1的报文，序列号为一随机数，客户端进入SYN_SENT状态 服务端收到SYN报文后，回复一个ACK和SYN都为1的报文，序列号为一随机数，确认应答号为收到的SYN报文的序列号+1，并从LISTEN状态进入SYN_RCVD状态 客户端收到报文后，回复一个ACK报文，确认应答号为收到的报文的序列号+1，并进入ESTABLISHED状态，服务端收到后也进入ESTABLISHED状态   为什么是三次握手？\n  保证双方具有接收和发送的能力 可以阻止重复历史连接的初始化（主要原因） 可以同步双方的初识序列号 可以避免资源浪费  四次挥手  客户端打算关闭连接，所以发送一个FIN报文，并从ESTABLISHED状态进入FIN_WAIT_1状态 服务端收到报文后回复一个ACK报文，进入CLOSED_WAIT状态，客户端收到后会进入FIN_WAIT_2状态 服务端处理完数据之后也发送一个FIN报文，之后进入LAST_ACK状态 客户端收到后回复一个ACK报文，并进入TIME_WAIT状态，在等待2MSL后关闭连接   TIME_WAIT状态为什么是2MSL？\n 防止第四次挥手的报文丢失，2MSL指的是第四次挥手报文以及如果第四次挥手报文丢失后，被动结束方重传的FIN报文\nTCP可靠性保证  应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。  协议 自动重传请求\n 停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认 连续ARQ协议：发送方维持一个发送窗口，接收方采取累积确认  重传机制  超时重传：发送数据时设置一个定时器，当超过指定时间后没有收到ACK报文就重传  超时重传时间RTO应略大于往返时延RTT   快速重传：当多次重复收到同一个ACK报文（累计应答），就重复后面的报文 SACK：在TCP头部加一个SACK，接收方可以缓存接收到哪些数据，并发送给发送方 D-SACK：用于告诉发送方有哪些数据被重复接收了  滑动窗口 引入窗口这个概念，解决往返时间过长造成的通信效果减低\n窗口大小指无需等待确认应答，而可以继续发送数据的最大值\n窗口可以分为4部分：1.已发送且已收到应答；2.已发送但未收到应答；3.未发送但总大小在接收方处理范围内（可用窗口）；4.未发送但大小超过接收方处理范围\n 接收窗口和发送窗口大小相等吗？\n 并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n因为滑动窗口并不是一成不变的\n流量控制 TCP提供的可以让发送方根据接收方的实际接收能力控制发送的数据量的机制\n当接收窗口收缩到0时，接收方发送消息通知发送方，发送窗口也收缩为0，当接收窗口不为0时发送一个窗口非0的报文，如果报文丢失就会造成死锁，TCP为每个连接设置了一个持续定时器，只要一方收到零窗口通知，就会启动计时器，如果计时器超时，就会发送窗口探测报文\n拥塞控制 为了避免网络出现拥堵时，发送方持续重传数据，从而造成恶性循环，在发送方设置一个拥塞窗口cwnd\n 什么情况是发生了拥塞？\n 只要发生了超时重传，就认为出现了拥塞\n 拥塞控制四个算法？\n  慢启动：当发送方每收到一个ACK，拥塞窗口cwnd的大小就加1，呈指数增长  当cwnd\u0026gt;=ssthresh（慢启动门限），就使用拥塞避免算法   拥塞避免算法：每收到一个ACK，cwnd就增加1/cwnd，呈线性增长  当触发了重传机制，就使用拥塞发生算法   拥塞发生  如果是超时重传，ssthresh设为cwnd/2，cwnd设置为1 如果是快速重传，cwnd设置为原来的一半，ssthresh设置为cwnd，进入快速恢复算法   快速恢复  cwnd设置为ssthresh+x(x为收到的重复确认应答数) 重传丢失的数据包 如果再收到重复的ACK，cwnd+1； 如果收到新的ACK，cwnd设置为第一步中ssthresh的值     拥塞控制和流量控制的区别？\n  流量控制是避免发送方的数据填满接收方的缓存  UDP 头部格式  TCP和UDP的区别？\n  连接：TCP是面向连接的，UDP是无连接的 服务对象：TCP只支持一对一，UDP支持一对一，一对多，多对多 可靠性：TCP是可靠交付的，UDP是尽最大努力交付 拥塞控制、流量控制：TCP有拥塞控制、流量控制机制来保证数据传输的安全性，UDP没有 首部开销：TCP最小20字节，UDP首部只有8字节 传输方式：TCP是流式传输，UDP是一个包一个包的传输 分片不同：TCP数据大小如果大于MSS大小，会在传输层进行分片、组装，UDP则在IP层 应用场景：TCP应用于FTP文件传输、HTTP等，UDP应用于视频、音频通信等  网络层协议 IP  IP地址分类？\n 无地址分类CIDR 不再有地址分类，而把地址分为网络号和主机号\n子网掩码与IP地址按位与得到网络号\nDNS域名解析  域名解析流程\n  首先会先查询浏览器和操作系统缓存 浏览器发送DNS请求后，会先发给本地域名服务器，如果有则返回对应的IP地址 如果没有则询问根域名服务器，根域名服务器会给你顶级域名服务器的地址 然后去询问顶级域名服务器，顶级域名服务器会给你权威DNS服务器的地址 然后去权威域名服务器查询IP地址，本地域名服务器得到IP地址后再返回给客户端  ARP 通过广播ARP请求，设备拿到ARP请求包后如果与自己的IP地址相同，就将自己的MAC地址放入ARP响应包中，返回给主机\nRARP 已知MAC地址求IP地址\nDHCP 用于给设备动态分配IP地址\n步骤：\n 客户端首先发起DHCP发现报文，全程使用UDP广播通信 DHCP服务器收到后，回复一个DHCP提供报文，报文携带可租约的IP地址、租期等信息 客户端收到后选择一个服务器，向其发送DHCP请求报文 DHCP服务器收到后用DHCP ACK报文进行响应  NAT 网络地址转换协议：用于缓解IP地址不足的问题\nICMP 互联网控制报文协议，功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。\nIGMP IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间\n Ping的工作原理\n 主机A Ping 主机B：主机A发送都会先用ARP协议来获得MAC地址，如果无法到达主机B，就会返回一个ICMP目标不可达报文\n","permalink":"https://oyzg.github.io/archives/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络面试相关内容.","title":"计算机网络"}]