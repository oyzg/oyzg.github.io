<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>二叉树 | My Favorite</title>
<meta name=keywords content="数据结构,算法,面试,二叉树,BFS,DFS"><meta name=description content="二叉树相关."><meta name=author content><link rel=canonical href=https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/><link href=/assets/css/stylesheet.min.d597aab94c71b49b163b6ac67c7958079589ea1a0b7300e8a0014e1d2023b95e.css integrity="sha256-1ZequUxxtJsWO2rGfHlYB5WJ6hoLcwDooAFOHSAjuV4=" rel="preload stylesheet" as=style><link rel=icon href=https://oyzg.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oyzg.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oyzg.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://oyzg.github.io/apple-touch-icon.png><link rel=mask-icon href=https://oyzg.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.147.4"><link rel=alternate hreflang=en href=https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/><meta property="og:title" content="二叉树"><meta property="og:description" content="二叉树相关."><meta property="og:type" content="article"><meta property="og:url" content="https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="article:published_time" content="2022-05-21T21:53:39+08:00"><meta property="article:modified_time" content="2022-05-21T21:53:39+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="二叉树"><meta name=twitter:description content="二叉树相关."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"二叉树","item":"https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"二叉树","name":"二叉树","description":"二叉树相关.","keywords":["数据结构","算法","面试","二叉树","BFS","DFS"],"articleBody":"二叉树 基础 先来看看定义：\n// Java public class TreeNode { int val; // 值 TreeNode left; // 左节点 TreeNode right;// 右节点 TreeNode() {} TreeNode(int val) { this.val = val; } } // Go type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。\n再来看看二叉树的存储方式\n二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果\n再来看看二叉树的遍历顺序：\n二叉树的遍历顺序有两种：\n深度优先遍历（DFS） 前序遍历 中序遍历 后序遍历 广度优先遍历（BFS） 深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现\n广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的\n最后来看看几个特别的二叉树：\n满二叉树：\n完全二叉树：\n完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况\n二叉搜索树：\n左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的\n平衡二叉搜索树（AVL）：\n在二叉搜索树的基础上，左右子树的高度差不超过1\n二叉树的遍历 前序遍历\n中序遍历\n后序遍历\n递归遍历 递归三要素：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} var preorder func(root *TreeNode) preorder = func(root * TreeNode) { if root == nil { return } res = append(res, root.Val) preorder(root.Left) preorder(root.Right) } preorder(root) return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} var inorder func(root *TreeNode) inorder = func(root * TreeNode) { if root == nil { return } inorder(root.Left) res = append(res, root.Val) inorder(root.Right) } inorder(root) return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} var postorder func(root *TreeNode) postorder = func(root * TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) res = append(res, root.Val) } postorder(root) return res } 迭代遍历 迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历\n// 前序遍历 func preorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u003e 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } // 中序遍历 func inorderTraversal(root *TreeNode) []int { res := []int{} cur := root stack := []*TreeNode{} for cur != nil || len(stack) \u003e 0 { if cur != nil { stack = append(stack, cur) cur = cur.Left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, cur.Val) cur = cur.Right } } return res } // 后序遍历 func postorderTraversal(root *TreeNode) []int { res := []int{} if root == nil { return res } stack := []*TreeNode{root} for len(stack) \u003e 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } reverse(res) return res } func reverse(a []int) { l, r := 0, len(a) - 1 for l \u003c r { a[l], a[r] = a[r], a[l] l, r = l+1, r-1 } } 此外迭代法还有统一的写法：\n/** type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (l *List) Back() *Element 前序遍历：中左右 压栈顺序：右左中 **/ func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u003e0{ e := stack.Back() stack.Remove(e)//弹出元素 if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右左中 if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) } return res } //中序遍历：左中右 //压栈顺序：右中左 func inorderTraversal(root *TreeNode) []int { if root==nil{ return nil } stack:=list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u003e0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：右中左 if node.Right!=nil{ stack.PushBack(node.Right) } stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Left!=nil{ stack.PushBack(node.Left) } } return res } //后续遍历：左右中 //压栈顺序：中右左 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } var stack = list.New()//栈 res:=[]int{}//结果集 stack.PushBack(root) var node *TreeNode for stack.Len()\u003e0{ e := stack.Back() stack.Remove(e) if e.Value==nil{// 如果为空，则表明是需要处理中间节点 e=stack.Back()//弹出元素（即中间节点） stack.Remove(e)//删除中间节点 node=e.Value.(*TreeNode) res=append(res,node.Val)//将中间节点加入到结果集中 continue//继续弹出栈中下一个节点 } node = e.Value.(*TreeNode) //压栈顺序：中右左 stack.PushBack(node)//中间节点压栈后再压入nil作为中间节点的标志符 stack.PushBack(nil) if node.Right!=nil{ stack.PushBack(node.Right) } if node.Left!=nil{ stack.PushBack(node.Left) } } return res } 层序遍历 [102. 二叉树的层序遍历] func levelOrder(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) level := []int{} for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } return res } 107.二叉树的层次遍历II // 思路：将层次遍历结果反转即可 func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) level := []int{} for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, level) } reverse(res) return res } func reverse(nums [][]int) { i, j := 0, len(nums)-1 for i \u003c j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } } 199.二叉树的右视图 // 思路：取右视图即取层次遍历结果每层的最后一个节点即可 func rightSideView(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] if i == size-1 { res = append(res, node.Val) } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return res } 637. 二叉树的层平均值 // BFS：每层取平均值即可 func averageOfLevels(root *TreeNode) []float64 { res := []float64{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) sum := 0 for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] sum += node.Val if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, float64(sum)/float64(size)) } return res } 429. N 叉树的层序遍历 // BFS func levelOrder(root *Node) [][]int { res := [][]int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) level := []int{} for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] level = append(level, node.Val) for _,child := range node.Children { if child != nil { queue = append(queue, child) } } } res = append(res, level) } return res } 515. 在每个树行中找最大值 // BFS func largestValues(root *TreeNode) []int { res := []int{} if root == nil { return res } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) max := queue[0].Val for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] if node.Val \u003e max { max = node.Val } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } res = append(res, max) } return res } 116. 填充每个节点的下一个右侧节点指针 // BFS func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u003e 0 { size := len(queue) var pre *Node = nil for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 117. 填充每个节点的下一个右侧节点指针 II // 同上 // TODO：其他解法 func connect(root *Node) *Node { if root == nil { return root } queue := []*Node{root} for len(queue) \u003e 0 { size := len(queue) var pre *Node = nil for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] if pre != nil { pre.Next = node } pre = node if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 104. 二叉树的最大深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth++ } return depth } 111. 二叉树的最小深度 func minDepth(root *TreeNode) int { if root == nil { return 0 } depth := 0 queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) depth++ for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] if node.Left == nil \u0026\u0026 node.Right == nil { return depth } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return depth } 常见算法题 226. 翻转二叉树 // 递归，左右节点互换即可 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) } return root } // 迭代法，使用BFS即可 func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return root } 101. 对称二叉树 // 递归法 func isSymmetric(root *TreeNode) bool { return defs(root.Left, root.Right) } // 将左右节点作为参数分别传入 func defs(left *TreeNode, right *TreeNode) bool { if left == nil \u0026\u0026 right == nil { return true; }; if left == nil || right == nil { return false; }; if left.Val != right.Val { return false; } return defs(left.Left, right.Right) \u0026\u0026 defs(right.Left, left.Right); } // 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{root.Left, root.Right} for len(queue) \u003e 0 { left := queue[0] right := queue[1] queue = queue[2:] if left == nil \u0026\u0026 right == nil { continue } if left == nil || right == nil || left.Val != right.Val { return false } queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } 559. N 叉树的最大深度 // BFS func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 queue := []*Node{root} for len(queue) \u003e 0 { size := len(queue) for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] for _, child := range node.Children { queue = append(queue, child) } } depth++ } return depth } 222. 完全二叉树的节点个数 func countNodes(root *TreeNode) int { if root == nil { return 0 } count := 0 queue := []*TreeNode{root} for len(queue) \u003e 0 { size := len(queue) for i := 0; i \u003c size; i++ { node := queue[0] queue = queue[1:] count++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return count } 110. 平衡二叉树\n// 递归法 func isBalanced(root *TreeNode) bool { return getHeight(root) != -1 } func getHeight(root *TreeNode) int { if root == nil { return 0 } left := getHeight(root.Left) right := getHeight(root.Right) if left == -1 || right == -1 || math.Abs(float64(left-right)) \u003e 1 { return -1 } return int(math.Max(float64(left), float64(right))) + 1 } 257. 二叉树的所有路径 // 递归法 func binaryTreePaths(root *TreeNode) []string { res := []string{} var travel func(root *TreeNode, s string) travel = func(root *TreeNode, s string) { if root.Left == nil \u0026\u0026 root.Right == nil { res = append(res, s + strconv.Itoa(root.Val)) return } s += strconv.Itoa(root.Val) + \"-\u003e\" if root.Left != nil { travel(root.Left, s) } if root.Right != nil { travel(root.Right, s) } } travel(root, \"\") return res } 100. 相同的树 // 递归 func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026\u0026 q == nil { return true } if p == nil || q == nil || p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026\u0026 isSameTree(p.Right, q.Right) } 404. 左叶子之和 func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } sum := 0 if root.Left != nil \u0026\u0026 root.Left.Left == nil \u0026\u0026 root.Left.Right == nil { sum += root.Left.Val } sum += sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) return sum } 513. 找树左下角的值 // 递归 func findBottomLeftValue(root *TreeNode) int { maxLen := 1 maxValue := root.Val var travel func(root *TreeNode, length int) travel = func(root *TreeNode, length int) { if root.Left == nil \u0026\u0026 root.Right == nil { if (length \u003e maxLen) { maxLen = length maxValue = root.Val return } } if root.Left != nil { travel(root.Left, length+1) } if root.Right != nil { travel(root.Right, length+1) } } travel(root, 1) return maxValue } 112. 路径总和 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } if targetSum == root.Val \u0026\u0026 root.Left == nil \u0026\u0026 root.Right == nil { return true } return hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val) } 113. 路径总和 II func pathSum(root *TreeNode, targetSum int) [][]int { res := [][]int{} var travel func(root *TreeNode, targetSum int, path []int) travel = func(root *TreeNode, targetSum int, path []int) { if root == nil { return } path = append(path, root.Val) if root.Left == nil \u0026\u0026 root.Right == nil \u0026\u0026 root.Val == targetSum { p := make([]int, len(path)) copy(p, path) // 注意此处，需要复制一个slice res = append(res, p) return } if root.Left != nil { travel(root.Left, targetSum - root.Val, path) } if root.Right != nil { travel(root.Right, targetSum - root.Val, path) } } travel(root, targetSum, []int{}) return res } 106. 从中序与后序遍历序列构造二叉树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n \u003c= 0 { return nil } mid := postorder[n-1] index := 0 for i := 0; i \u003c n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026TreeNode { Val: mid, Left: buildTree(inorder[:index], postorder[:index]), Right: buildTree(inorder[index+1:], postorder[index:n-1]), } return root } 105. 从前序与中序遍历序列构造二叉树 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(inorder) if n \u003c= 0 { return nil } mid := preorder[0] index := 0 for i := 0; i \u003c n; i++ { // 找到root节点在inorder中的下标 if inorder[i] == mid { index = i break } } root := \u0026TreeNode { Val: mid, Left: buildTree(preorder[1:index+1], inorder[:index]), Right: buildTree(preorder[index+1:], inorder[index+1:]), } return root } 654. 最大二叉树 func constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) \u003c= 0 { return nil } maxNum := nums[0] maxIndex := 0 for i, v := range nums { if v \u003e maxNum { maxNum = v maxIndex = i } } return \u0026TreeNode { Val: maxNum, Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), } } 617. 合并二叉树 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026\u0026 root2 == nil { return nil } root := \u0026TreeNode {} if root1 == nil { root = root2 } else if root2 == nil { root = root1 } else { root = \u0026TreeNode { Val: root1.Val+root2.Val, Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), } } return root } 700. 二叉搜索树中的搜索 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val == val { return root } node := searchBST(root.Left, val) if node != nil { return node } node = searchBST(root.Right, val) return node } 98. 验证二叉搜索树 func isValidBST(root *TreeNode) bool { var verify func(root *TreeNode, min, max int64) bool verify = func(root *TreeNode, min, max int64) bool { if root == nil { return true } if min \u003e= int64(root.Val) || max \u003c= int64(root.Val) { return false } // 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true return verify(root.Right,int64(root.Val),max) \u0026\u0026 verify(root.Left,min,int64(root.Val)) } return verify(root, math.MinInt64, math.MaxInt64) } 530. 二叉搜索树的最小绝对差 // 递归 func getMinimumDifference(root *TreeNode) int { var dfs func(node *TreeNode) min := 100000 pre := -1 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if pre != -1 \u0026\u0026 node.Val - pre \u003c min { min = node.Val - pre } pre = node.Val dfs(node.Right) } dfs(root) return min } 501. 二叉搜索树中的众数 // 计数 func findMode(root *TreeNode) []int { var dfs func(node *TreeNode) res := []int{} maxCount := 0 count := 0 cur := 0 dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) if node.Val == cur { count++ } else { count = 1 } cur = node.Val if count \u003e maxCount { maxCount = count res = []int{} } if count == maxCount { res = append(res, cur) } dfs(node.Right) } dfs(root) return res } 236. 二叉树的最近公共祖先 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026\u0026 right != nil { return root } if left != nil { return left } if right != nil { return right } return nil } 235. 二叉搜索树的最近公共祖先\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == q || root == p || (root.Val \u003e= p.Val \u0026\u0026 root.Val \u003c= q.Val) || (root.Val \u003c= p.Val \u0026\u0026 root.Val \u003e= q.Val) { return root } if root.Val \u003e p.Val \u0026\u0026 root.Val \u003e q.Val { return lowestCommonAncestor(root.Left, p, q) } if root.Val \u003c p.Val \u0026\u0026 root.Val \u003c q.Val { return lowestCommonAncestor(root.Right, p, q) } return nil } 701. 二叉搜索树中的插入操作 // 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } cur := root for cur != nil { if cur.Val \u003e val { if cur.Left == nil { cur.Left = \u0026TreeNode{ Val: val, } return root } cur = cur.Left } else { if cur.Right == nil { cur.Right = \u0026TreeNode{ Val: val, } return root } cur = cur.Right } } return root } 450. 删除二叉搜索树中的节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { if root.Left == nil \u0026\u0026 root.Right == nil { return nil } else if root.Right == nil { return root.Left } else if root.Left == nil { return root.Right } else { cur := root.Right for cur.Left != nil { cur = cur.Left } cur.Left = root.Left return root.Right } } else if root.Val \u003e key { root.Left = deleteNode(root.Left, key) } else { root.Right = deleteNode(root.Right, key) } return root } 669. 修剪二叉搜索树 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } else if root.Val \u003c low { return trimBST(root.Right, low, high) } else if root.Val \u003e high { return trimBST(root.Left, low, high) } else { root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) } return root } 108. 将有序数组转换为二叉搜索树 func sortedArrayToBST(nums []int) *TreeNode { n := len(nums) if n == 0 { return nil } mid := n/2 root := \u0026TreeNode { Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } return root } 538. 把二叉搜索树转换为累加树 func convertBST(root *TreeNode) *TreeNode { sum := 0 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Right) node.Val = sum + node.Val sum = node.Val dfs(node.Left) } dfs(root) return root } ","wordCount":"3157","inLanguage":"en","datePublished":"2022-05-21T21:53:39+08:00","dateModified":"2022-05-21T21:53:39+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://oyzg.github.io/archives/%E4%BA%8C%E5%8F%89%E6%A0%91/"},"publisher":{"@type":"Organization","name":"My Favorite","logo":{"@type":"ImageObject","url":"https://oyzg.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://oyzg.github.io/ accesskey=h title="My Favorite (Alt + H)">My Favorite</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://oyzg.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://oyzg.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://oyzg.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://oyzg.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://oyzg.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>二叉树</h1><div class=post-meta>May 21, 2022&amp;nbsp;·&amp;nbsp;15 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label=二叉树>二叉树</a><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a><ul><li><a href=#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86 aria-label=二叉树的遍历>二叉树的遍历</a><ul><li><a href=#%e9%80%92%e5%bd%92%e9%81%8d%e5%8e%86 aria-label=递归遍历>递归遍历</a></li><li><a href=#%e8%bf%ad%e4%bb%a3%e9%81%8d%e5%8e%86 aria-label=迭代遍历>迭代遍历</a></li><li><a href=#%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label=层序遍历>层序遍历</a><ul><li><a href=#heading aria-label="[102. 二叉树的层序遍历]"><a href=https://leetcode.cn/problems/binary-tree-level-order-traversal/>[102. 二叉树的层序遍历]</a></a></li><li><a href=#107%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e6%ac%a1%e9%81%8d%e5%8e%86ii aria-label=107.二叉树的层次遍历II><a href>107.二叉树的层次遍历II</a></a></li><li><a href=#199%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%8f%b3%e8%a7%86%e5%9b%be aria-label=199.二叉树的右视图><a href>199.二叉树的右视图</a></a></li><li><a href=#637-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%b9%b3%e5%9d%87%e5%80%bc aria-label="637. 二叉树的层平均值"><a href=https://leetcode.cn/problems/average-of-levels-in-binary-tree/>637. 二叉树的层平均值</a></a></li><li><a href=#429-n-%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86 aria-label="429. N 叉树的层序遍历"><a href=https://leetcode.cn/problems/n-ary-tree-level-order-traversal/>429. N 叉树的层序遍历</a></a></li><li><a href=#515-%e5%9c%a8%e6%af%8f%e4%b8%aa%e6%a0%91%e8%a1%8c%e4%b8%ad%e6%89%be%e6%9c%80%e5%a4%a7%e5%80%bc aria-label="515. 在每个树行中找最大值"><a href=https://leetcode.cn/problems/find-largest-value-in-each-tree-row/>515. 在每个树行中找最大值</a></a></li><li><a href=#116-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88 aria-label="116. 填充每个节点的下一个右侧节点指针"><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/>116. 填充每个节点的下一个右侧节点指针</a></a></li><li><a href=#117-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88-ii aria-label="117. 填充每个节点的下一个右侧节点指针 II"><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/>117. 填充每个节点的下一个右侧节点指针 II</a></a></li><li><a href=#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6 aria-label="104. 二叉树的最大深度"><a href=https://leetcode.cn/problems/maximum-depth-of-binary-tree/>104. 二叉树的最大深度</a></a></li><li><a href=#111-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e6%b7%b1%e5%ba%a6 aria-label="111. 二叉树的最小深度"><a href=https://leetcode.cn/problems/minimum-depth-of-binary-tree/>111. 二叉树的最小深度</a></a></li></ul></li></ul></li></ul></li><li><a href=#%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95%e9%a2%98 aria-label=常见算法题>常见算法题</a><ul><ul><li><a href=#226-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="226. 翻转二叉树"><a href=https://leetcode.cn/problems/invert-binary-tree/>226. 翻转二叉树</a></a></li><li><a href=#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="101. 对称二叉树"><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a></a></li><li><a href=#559-n-%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6 aria-label="559. N 叉树的最大深度"><a href=https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/>559. N 叉树的最大深度</a></a></li><li><a href=#222-%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0 aria-label="222. 完全二叉树的节点个数"><a href=https://leetcode.cn/problems/count-complete-tree-nodes/>222. 完全二叉树的节点个数</a></a></li><li><a href=#257-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%89%80%e6%9c%89%e8%b7%af%e5%be%84 aria-label="257. 二叉树的所有路径"><a href=https://leetcode.cn/problems/binary-tree-paths/>257. 二叉树的所有路径</a></a></li><li><a href=#100-%e7%9b%b8%e5%90%8c%e7%9a%84%e6%a0%91 aria-label="100. 相同的树"><a href=https://leetcode.cn/problems/same-tree/>100. 相同的树</a></a></li><li><a href=#404-%e5%b7%a6%e5%8f%b6%e5%ad%90%e4%b9%8b%e5%92%8c aria-label="404. 左叶子之和"><a href=https://leetcode.cn/problems/sum-of-left-leaves/>404. 左叶子之和</a></a></li><li><a href=#513-%e6%89%be%e6%a0%91%e5%b7%a6%e4%b8%8b%e8%a7%92%e7%9a%84%e5%80%bc aria-label="513. 找树左下角的值"><a href=https://leetcode.cn/problems/find-bottom-left-tree-value/>513. 找树左下角的值</a></a></li><li><a href=#112-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c aria-label="112. 路径总和"><a href=https://leetcode.cn/problems/path-sum/>112. 路径总和</a></a></li><li><a href=#113-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-ii aria-label="113. 路径总和 II"><a href=https://leetcode.cn/problems/path-sum-ii/>113. 路径总和 II</a></a></li><li><a href=#106-%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="106. 从中序与后序遍历序列构造二叉树"><a href=https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106. 从中序与后序遍历序列构造二叉树</a></a></li><li><a href=#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="105. 从前序与中序遍历序列构造二叉树"><a href=https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. 从前序与中序遍历序列构造二叉树</a></a></li><li><a href=#654-%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="654. 最大二叉树"><a href=https://leetcode.cn/problems/maximum-binary-tree/>654. 最大二叉树</a></a></li><li><a href=#617-%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="617. 合并二叉树"><a href=https://leetcode.cn/problems/merge-two-binary-trees/>617. 合并二叉树</a></a></li><li><a href=#700-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2 aria-label="700. 二叉搜索树中的搜索"><a href=https://leetcode.cn/problems/search-in-a-binary-search-tree/>700. 二叉搜索树中的搜索</a></a></li><li><a href=#98-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91 aria-label="98. 验证二叉搜索树"><a href=https://leetcode.cn/problems/validate-binary-search-tree/>98. 验证二叉搜索树</a></a></li><li><a href=#530-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e5%b0%8f%e7%bb%9d%e5%af%b9%e5%b7%ae aria-label="530. 二叉搜索树的最小绝对差"><a href=https://leetcode.cn/problems/minimum-absolute-difference-in-bst/>530. 二叉搜索树的最小绝对差</a></a></li><li><a href=#501-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e4%bc%97%e6%95%b0 aria-label="501. 二叉搜索树中的众数"><a href=https://leetcode.cn/problems/find-mode-in-binary-search-tree/>501. 二叉搜索树中的众数</a></a></li><li><a href=#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88 aria-label="236. 二叉树的最近公共祖先"><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>236. 二叉树的最近公共祖先</a></a></li><li><a href=#701-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c aria-label="701. 二叉搜索树中的插入操作"><a href=https://leetcode.cn/problems/insert-into-a-binary-search-tree/>701. 二叉搜索树中的插入操作</a></a></li><li><a href=#450-%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9 aria-label="450. 删除二叉搜索树中的节点"><a href=https://leetcode.cn/problems/delete-node-in-a-bst/>450. 删除二叉搜索树中的节点</a></a></li><li><a href=#669-%e4%bf%ae%e5%89%aa%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91 aria-label="669. 修剪二叉搜索树"><a href=https://leetcode.cn/problems/trim-a-binary-search-tree/>669. 修剪二叉搜索树</a></a></li><li><a href=#108-%e5%b0%86%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91 aria-label="108. 将有序数组转换为二叉搜索树"><a href=https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/>108. 将有序数组转换为二叉搜索树</a></a></li><li><a href=#538-%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%b4%af%e5%8a%a0%e6%a0%91 aria-label="538. 把二叉搜索树转换为累加树"><a href=https://leetcode.cn/problems/convert-bst-to-greater-tree/>538. 把二叉搜索树转换为累加树</a></a></li></ul></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=二叉树>二叉树<a hidden class=anchor aria-hidden=true href=#二叉树>#</a></h1><h2 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h2><p>先来看看<strong>定义</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Java</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val; <span style=color:#75715e>// 值</span>
</span></span><span style=display:flex><span>  	TreeNode left; <span style=color:#75715e>// 左节点</span>
</span></span><span style=display:flex><span>  	TreeNode right;<span style=color:#75715e>// 右节点</span>
</span></span><span style=display:flex><span>  	TreeNode() {}
</span></span><span style=display:flex><span>  	TreeNode(<span style=color:#66d9ef>int</span> val) { <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>val</span> <span style=color:#f92672>=</span> val; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Go</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TreeNode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Val</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Left</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>二叉树在结构上其实很简单，就是有一个左节点和一个右节点，相比于链表多了一个左节点，如果左节点都为null，那就成了链表。</p><p>再来看看二叉树的<strong>存储方式</strong></p><p>二叉树的存储结构有两种，一种链式存储，一种顺序存储，平时我们看到的可能都是链式存储结构，顺序存储也很简单，就是二叉树的层次遍历结果</p><p><img src=/images/%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20220522102758379.png alt=image-20220522102758379></p><p>再来看看二叉树的<strong>遍历顺序</strong>：</p><p>二叉树的遍历顺序有两种：</p><ul><li>深度优先遍历（DFS）<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li><li>广度优先遍历（BFS）</li></ul><p>深度优先遍历的三种顺序指的是中间节点的遍历顺序，比如中序遍历就是左中右，中在中间遍历，所以是中序遍历；此外这三种遍历都有两种实现方法，递归法和迭代法，递归的本质就是栈，所以迭代法其实就是用栈实现</p><p>广度优先遍历比较简单，它的实现只有一种方法，迭代法，是用队列来实现的</p><p>最后来看看几个特别的二叉树：</p><p><strong>满二叉树</strong>：</p><p><img src=/images/%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20220522103534130.png alt=image-20220522103534130></p><p><strong>完全二叉树</strong>：</p><p>完全二叉树是完全按照从上到下，从左到右的顺序来摆放的，所以不可能有上面某个节点为空，或者左边某个节点为空的情况</p><p><strong>二叉搜索树</strong>：</p><p>左子树的所有节点都小于根节点，右子树的所有节点都大于根节点，中序遍历结果是递增的</p><p><strong>平衡二叉搜索树（AVL）</strong>：</p><p>在二叉搜索树的基础上，左右子树的高度差不超过1</p><h3 id=二叉树的遍历>二叉树的遍历<a hidden class=anchor aria-hidden=true href=#二叉树的遍历>#</a></h3><p><a href=https://leetcode.cn/problems/binary-tree-preorder-traversal/>前序遍历</a></p><p><a href=https://leetcode.cn/problems/binary-tree-inorder-traversal/>中序遍历</a></p><p><a href=https://leetcode.cn/problems/binary-tree-postorder-traversal/>后序遍历</a></p><h4 id=递归遍历>递归遍历<a hidden class=anchor aria-hidden=true href=#递归遍历>#</a></h4><p>递归三要素：</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Definition for a binary tree node.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * type TreeNode struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Val int
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Left *TreeNode
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Right *TreeNode
</span></span></span><span style=display:flex><span><span style=color:#75715e> * }
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 前序遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>preorder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>preorder</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>preorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>preorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>preorder</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 中序遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inorder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inorder</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>inorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>inorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inorder</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 后序遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>postorder</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postorder</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>postorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>postorder</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postorder</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=迭代遍历>迭代遍历<a hidden class=anchor aria-hidden=true href=#迭代遍历>#</a></h4><p>迭代法就是用栈来模拟递归，因为前序遍历和后序遍历都可以通过先遍历中间节点来实现，因为栈是先进后出，所以需要反着来，前序遍历入栈的时候先放入右节点，再放入左节点，而中间节点直接加入到结果中；而后序遍历就是反过来，先放入左节点，再放入右节点，最后的结果是中右左，所以最后需要将结果反转；而中序遍历则不能和前2种一样，需要使用指针来遍历</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 前序遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 中序遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>cur</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 后序遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>a</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>l</span> &lt; <span style=color:#a6e22e>r</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>l</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>] = <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>l</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>l</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>r</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外迭代法还有统一的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> type Element struct {
</span></span></span><span style=display:flex><span><span style=color:#75715e>    // 元素保管的值
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Value interface{}
</span></span></span><span style=display:flex><span><span style=color:#75715e>    // 内含隐藏或非导出字段
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>func (l *List) Back() *Element 
</span></span></span><span style=display:flex><span><span style=color:#75715e>前序遍历：中左右
</span></span></span><span style=display:flex><span><span style=color:#75715e>压栈顺序：右左中
</span></span></span><span style=display:flex><span><span style=color:#75715e> **/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>()<span style=color:#75715e>//栈</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span><span style=color:#f92672>:=</span>[]<span style=color:#66d9ef>int</span>{}<span style=color:#75715e>//结果集</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Len</span>()&gt;<span style=color:#ae81ff>0</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//弹出元素</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{<span style=color:#75715e>// 如果为空，则表明是需要处理中间节点</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>e</span>=<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()<span style=color:#75715e>//弹出元素（即中间节点）</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//删除中间节点</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>=<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>=append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)<span style=color:#75715e>//将中间节点加入到结果集中</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span><span style=color:#75715e>//继续弹出栈中下一个节点</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//压栈顺序：右左中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>)<span style=color:#75715e>//中间节点压栈后再压入nil作为中间节点的标志符</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//中序遍历：左中右</span>
</span></span><span style=display:flex><span> <span style=color:#75715e>//压栈顺序：右中左</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span><span style=color:#f92672>:=</span><span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>()<span style=color:#75715e>//栈</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span><span style=color:#f92672>:=</span>[]<span style=color:#66d9ef>int</span>{}<span style=color:#75715e>//结果集</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Len</span>()&gt;<span style=color:#ae81ff>0</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{<span style=color:#75715e>// 如果为空，则表明是需要处理中间节点</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>e</span>=<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()<span style=color:#75715e>//弹出元素（即中间节点）</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//删除中间节点</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>=<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>=append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)<span style=color:#75715e>//将中间节点加入到结果集中</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span><span style=color:#75715e>//继续弹出栈中下一个节点</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//压栈顺序：右中左</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>)<span style=color:#75715e>//中间节点压栈后再压入nil作为中间节点的标志符</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//后续遍历：左右中</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//压栈顺序：中右左</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>()<span style=color:#75715e>//栈</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span><span style=color:#f92672>:=</span>[]<span style=color:#66d9ef>int</span>{}<span style=color:#75715e>//结果集</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Len</span>()&gt;<span style=color:#ae81ff>0</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{<span style=color:#75715e>// 如果为空，则表明是需要处理中间节点</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>e</span>=<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Back</span>()<span style=color:#75715e>//弹出元素（即中间节点）</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>e</span>)<span style=color:#75715e>//删除中间节点</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>=<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>=append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)<span style=color:#75715e>//将中间节点加入到结果集中</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span><span style=color:#75715e>//继续弹出栈中下一个节点</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//压栈顺序：中右左</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>)<span style=color:#75715e>//中间节点压栈后再压入nil作为中间节点的标志符</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>PushBack</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=层序遍历>层序遍历<a hidden class=anchor aria-hidden=true href=#层序遍历>#</a></h4><h5 id=heading><a href=https://leetcode.cn/problems/binary-tree-level-order-traversal/>[102. 二叉树的层序遍历]</a><a hidden class=anchor aria-hidden=true href=#heading>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrder</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>level</span> = append(<span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=107二叉树的层次遍历ii><a href>107.二叉树的层次遍历II</a><a hidden class=anchor aria-hidden=true href=#107二叉树的层次遍历ii>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 思路：将层次遍历结果反转即可</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrderBottom</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>level</span> = append(<span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>nums</span> [][]<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>nums</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>j</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>j</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=199二叉树的右视图><a href>199.二叉树的右视图</a><a hidden class=anchor aria-hidden=true href=#199二叉树的右视图>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 思路：取右视图即取层次遍历结果每层的最后一个节点即可</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rightSideView</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=637-二叉树的层平均值><a href=https://leetcode.cn/problems/average-of-levels-in-binary-tree/>637. 二叉树的层平均值</a><a hidden class=anchor aria-hidden=true href=#637-二叉树的层平均值>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS：每层取平均值即可</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>averageOfLevels</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>float64</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>float64</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, float64(<span style=color:#a6e22e>sum</span>)<span style=color:#f92672>/</span>float64(<span style=color:#a6e22e>size</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=429-n-叉树的层序遍历><a href=https://leetcode.cn/problems/n-ary-tree-level-order-traversal/>429. N 叉树的层序遍历</a><a hidden class=anchor aria-hidden=true href=#429-n-叉树的层序遍历>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrder</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>level</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>level</span> = append(<span style=color:#a6e22e>level</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>,<span style=color:#a6e22e>child</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Children</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>child</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>level</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=515-在每个树行中找最大值><a href=https://leetcode.cn/problems/find-largest-value-in-each-tree-row/>515. 在每个树行中找最大值</a><a hidden class=anchor aria-hidden=true href=#515-在每个树行中找最大值>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>largestValues</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>max</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>max</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>max</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>max</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=116-填充每个节点的下一个右侧节点指针><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/>116. 填充每个节点的下一个右侧节点指针</a><a hidden class=anchor aria-hidden=true href=#116-填充每个节点的下一个右侧节点指针>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pre</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=117-填充每个节点的下一个右侧节点指针-ii><a href=https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/>117. 填充每个节点的下一个右侧节点指针 II</a><a hidden class=anchor aria-hidden=true href=#117-填充每个节点的下一个右侧节点指针-ii>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 同上 </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TODO：其他解法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>pre</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=104-二叉树的最大深度><a href=https://leetcode.cn/problems/maximum-depth-of-binary-tree/>104. 二叉树的最大深度</a><a hidden class=anchor aria-hidden=true href=#104-二叉树的最大深度>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=111-二叉树的最小深度><a href=https://leetcode.cn/problems/minimum-depth-of-binary-tree/>111. 二叉树的最小深度</a><a hidden class=anchor aria-hidden=true href=#111-二叉树的最小深度>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>minDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }   
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=常见算法题>常见算法题<a hidden class=anchor aria-hidden=true href=#常见算法题>#</a></h2><h4 id=226-翻转二叉树><a href=https://leetcode.cn/problems/invert-binary-tree/>226. 翻转二叉树</a><a hidden class=anchor aria-hidden=true href=#226-翻转二叉树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归，左右节点互换即可</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>), <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 迭代法，使用BFS即可</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }   
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=101-对称二叉树><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a><a hidden class=anchor aria-hidden=true href=#101-对称二叉树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSymmetric</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 将左右节点作为参数分别传入</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>left</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Right</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>defs</span>(<span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Right</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 迭代法：在加入队列时将相对应的一起加入，取出时也一起取出</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSymmetric</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=559-n-叉树的最大深度><a href=https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/>559. N 叉树的最大深度</a><a hidden class=anchor aria-hidden=true href=#559-n-叉树的最大深度>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BFS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>child</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Children</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>child</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=222-完全二叉树的节点个数><a href=https://leetcode.cn/problems/count-complete-tree-nodes/>222. 完全二叉树的节点个数</a><a hidden class=anchor aria-hidden=true href=#222-完全二叉树的节点个数>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>countNodes</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode.cn/problems/balanced-binary-tree/>110. 平衡二叉树</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isBalanced</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span>) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getHeight</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Abs</span>(float64(<span style=color:#a6e22e>left</span><span style=color:#f92672>-</span><span style=color:#a6e22e>right</span>)) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Max</span>(float64(<span style=color:#a6e22e>left</span>), float64(<span style=color:#a6e22e>right</span>))) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=257-二叉树的所有路径><a href=https://leetcode.cn/problems/binary-tree-paths/>257. 二叉树的所有路径</a><a hidden class=anchor aria-hidden=true href=#257-二叉树的所有路径>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>binaryTreePaths</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>travel</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;-&gt;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=100-相同的树><a href=https://leetcode.cn/problems/same-tree/>100. 相同的树</a><a hidden class=anchor aria-hidden=true href=#100-相同的树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSameTree</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>isSameTree</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Left</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>isSameTree</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=404-左叶子之和><a href=https://leetcode.cn/problems/sum-of-left-leaves/>404. 左叶子之和</a><a hidden class=anchor aria-hidden=true href=#404-左叶子之和>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumOfLeftLeaves</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>sumOfLeftLeaves</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>sumOfLeftLeaves</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=513-找树左下角的值><a href=https://leetcode.cn/problems/find-bottom-left-tree-value/>513. 找树左下角的值</a><a hidden class=anchor aria-hidden=true href=#513-找树左下角的值>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findBottomLeftValue</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxLen</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>travel</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>length</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>length</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>length</span> &gt; <span style=color:#a6e22e>maxLen</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>maxLen</span> = <span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>maxValue</span> = <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>length</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>length</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>maxValue</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=112-路径总和><a href=https://leetcode.cn/problems/path-sum/>112. 路径总和</a><a hidden class=anchor aria-hidden=true href=#112-路径总和>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hasPathSum</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hasPathSum</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>hasPathSum</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=113-路径总和-ii><a href=https://leetcode.cn/problems/path-sum-ii/>113. 路径总和 II</a><a hidden class=anchor aria-hidden=true href=#113-路径总和-ii>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pathSum</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>) [][]<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>travel</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>path</span> []<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>path</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>path</span> = append(<span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>targetSum</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>path</span>))
</span></span><span style=display:flex><span>            copy(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>path</span>) <span style=color:#75715e>// 注意此处，需要复制一个slice</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>, <span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>targetSum</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>, <span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>travel</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>targetSum</span>, []<span style=color:#66d9ef>int</span>{})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=106-从中序与后序遍历序列构造二叉树><a href=https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106. 从中序与后序遍历序列构造二叉树</a><a hidden class=anchor aria-hidden=true href=#106-从中序与后序遍历序列构造二叉树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>inorder</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>postorder</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>inorder</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>postorder</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>// 找到root节点在inorder中的下标</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>mid</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>mid</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>inorder</span>[:<span style=color:#a6e22e>index</span>], <span style=color:#a6e22e>postorder</span>[:<span style=color:#a6e22e>index</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#a6e22e>postorder</span>[<span style=color:#a6e22e>index</span>:<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=105-从前序与中序遍历序列构造二叉树><a href=https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. 从前序与中序遍历序列构造二叉树</a><a hidden class=anchor aria-hidden=true href=#105-从前序与中序遍历序列构造二叉树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>preorder</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>inorder</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>inorder</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>preorder</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>// 找到root节点在inorder中的下标</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>mid</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>mid</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>preorder</span>[<span style=color:#ae81ff>1</span>:<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>inorder</span>[:<span style=color:#a6e22e>index</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>buildTree</span>(<span style=color:#a6e22e>preorder</span>[<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#a6e22e>inorder</span>[<span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=654-最大二叉树><a href=https://leetcode.cn/problems/maximum-binary-tree/>654. 最大二叉树</a><a hidden class=anchor aria-hidden=true href=#654-最大二叉树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>constructMaximumBinaryTree</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>nums</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxNum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxIndex</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#a6e22e>maxNum</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxNum</span> = <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxIndex</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>maxNum</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>constructMaximumBinaryTree</span>(<span style=color:#a6e22e>nums</span>[:<span style=color:#a6e22e>maxIndex</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>constructMaximumBinaryTree</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>maxIndex</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=617-合并二叉树><a href=https://leetcode.cn/problems/merge-two-binary-trees/>617. 合并二叉树</a><a hidden class=anchor aria-hidden=true href=#617-合并二叉树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>root1</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>root2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root2</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span> = <span style=color:#a6e22e>root2</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root2</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span> = <span style=color:#a6e22e>root1</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>root1</span>.<span style=color:#a6e22e>Val</span><span style=color:#f92672>+</span><span style=color:#a6e22e>root2</span>.<span style=color:#a6e22e>Val</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>root1</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>root2</span>.<span style=color:#a6e22e>Left</span>),
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>root1</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>root2</span>.<span style=color:#a6e22e>Right</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=700-二叉搜索树中的搜索><a href=https://leetcode.cn/problems/search-in-a-binary-search-tree/>700. 二叉搜索树中的搜索</a><a hidden class=anchor aria-hidden=true href=#700-二叉搜索树中的搜索>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>searchBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>searchBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>  <span style=color:#a6e22e>node</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> = <span style=color:#a6e22e>searchBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=98-验证二叉搜索树><a href=https://leetcode.cn/problems/validate-binary-search-tree/>98. 验证二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#98-验证二叉搜索树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isValidBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>verify</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>min</span>, <span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>verify</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>min</span>, <span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>min</span> <span style=color:#f92672>&gt;=</span> int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>max</span> <span style=color:#f92672>&lt;=</span> int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>verify</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>,int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>),<span style=color:#a6e22e>max</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>verify</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>,<span style=color:#a6e22e>min</span>,int64(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>verify</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MinInt64</span>, <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MaxInt64</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=530-二叉搜索树的最小绝对差><a href=https://leetcode.cn/problems/minimum-absolute-difference-in-bst/>530. 二叉搜索树的最小绝对差</a><a hidden class=anchor aria-hidden=true href=#530-二叉搜索树的最小绝对差>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 递归</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getMinimumDifference</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>min</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>100000</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pre</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pre</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>pre</span> &lt; <span style=color:#a6e22e>min</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>min</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>pre</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pre</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>min</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=501-二叉搜索树中的众数><a href=https://leetcode.cn/problems/find-mode-in-binary-search-tree/>501. 二叉搜索树中的众数</a><a hidden class=anchor aria-hidden=true href=#501-二叉搜索树中的众数>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 计数</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findMode</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>cur</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>count</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> &gt; <span style=color:#a6e22e>maxCount</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxCount</span> = <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>maxCount</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>cur</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=236-二叉树的最近公共祖先><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>236. 二叉树的最近公共祖先</a><a hidden class=anchor aria-hidden=true href=#236-二叉树的最近公共祖先>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>left</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>right</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/>235. 二叉搜索树的最近公共祖先</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &lt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &lt; <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lowestCommonAncestor</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>q</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=701-二叉搜索树中的插入操作><a href=https://leetcode.cn/problems/insert-into-a-binary-search-tree/>701. 二叉搜索树中的插入操作</a><a hidden class=anchor aria-hidden=true href=#701-二叉搜索树中的插入操作>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 利用二叉搜索树的性质找到要插入的位置，注意root可能为nil</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>insertIntoBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>val</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>cur</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>val</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>val</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>val</span>,
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=450-删除二叉搜索树中的节点><a href=https://leetcode.cn/problems/delete-node-in-a-bst/>450. 删除二叉搜索树中的节点</a><a hidden class=anchor aria-hidden=true href=#450-删除二叉搜索树中的节点>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deleteNode</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>key</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cur</span> = <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cur</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>key</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>deleteNode</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>deleteNode</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=669-修剪二叉搜索树><a href=https://leetcode.cn/problems/trim-a-binary-search-tree/>669. 修剪二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#669-修剪二叉搜索树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>low</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>high</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &lt; <span style=color:#a6e22e>low</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span> &gt; <span style=color:#a6e22e>high</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>trimBST</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>low</span>, <span style=color:#a6e22e>high</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=108-将有序数组转换为二叉搜索树><a href=https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/>108. 将有序数组转换为二叉搜索树</a><a hidden class=anchor aria-hidden=true href=#108-将有序数组转换为二叉搜索树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>],
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span>[:<span style=color:#a6e22e>mid</span>]),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=538-把二叉搜索树转换为累加树><a href=https://leetcode.cn/problems/convert-bst-to-greater-tree/>538. 把二叉搜索树转换为累加树</a><a hidden class=anchor aria-hidden=true href=#538-把二叉搜索树转换为累加树>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convertBST</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dfs</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>)  {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span> = <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sum</span> = <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>root</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://oyzg.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=https://oyzg.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://oyzg.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></li><li><a href=https://oyzg.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/>二叉树</a></li><li><a href=https://oyzg.github.io/tags/bfs/>BFS</a></li><li><a href=https://oyzg.github.io/tags/dfs/>DFS</a></li></ul><nav class=paginav><a class=prev href=https://oyzg.github.io/archives/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/><span class=title>« Prev Page</span><br><span>回溯算法</span>
</a><a class=next href=https://oyzg.github.io/archives/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/><span class=title>Next Page »</span><br><span>栈和队列</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on twitter" href="https://twitter.com/intent/tweet/?text=%e4%ba%8c%e5%8f%89%e6%a0%91&amp;url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f&amp;hashtags=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%2c%e7%ae%97%e6%b3%95%2c%e9%9d%a2%e8%af%95%2c%e4%ba%8c%e5%8f%89%e6%a0%91%2cBFS%2cDFS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f&amp;title=%e4%ba%8c%e5%8f%89%e6%a0%91&amp;summary=%e4%ba%8c%e5%8f%89%e6%a0%91&amp;source=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f&title=%e4%ba%8c%e5%8f%89%e6%a0%91"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%ba%8c%e5%8f%89%e6%a0%91%20-%20https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 二叉树 on telegram" href="https://telegram.me/share/url?text=%e4%ba%8c%e5%8f%89%e6%a0%91&amp;url=https%3a%2f%2foyzg.github.io%2farchives%2f%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oyzg.github.io/>My Favorite</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g>
<svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a><script defer src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>